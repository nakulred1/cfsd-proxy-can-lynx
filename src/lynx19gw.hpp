/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Thu May  7 12:29:31 2020.
 */

#ifndef LYNX19GW_H
#define LYNX19GW_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

#define LYNX19GW_AS_TORQUE_REQ_FRAME_ID (0xe1u)
#define LYNX19GW_AS_DL_SENSORS_FRAME_ID (0xe2u)
#define LYNX19GW_NR_DL_SENSORS_4_NEW_FRAME_ID (0xb7u)
#define LYNX19GW_NR_DL_TV_OUT_3_NEW_FRAME_ID (0xb6u)
#define LYNX19GW_DL_AS_STATUS_FRAME_ID (0xd4u)
#define LYNX19GW_NR_DL_TV_OUT_2_FRAME_ID (0xb5u)
#define LYNX19GW_NR_DL_TV_OUT_1_FRAME_ID (0xb4u)
#define LYNX19GW_DL_NR_TV_CONF_2_FRAME_ID (0xd2u)
#define LYNX19GW_DL_NR_TV_CONF_1_FRAME_ID (0xd1u)
#define LYNX19GW_PER_PDO_1_TX_FRAME_ID (0x185u)
#define LYNX19GW_PER_PDO_2_TX_FRAME_ID (0x285u)
#define LYNX19GW_PEL_PDO_2_TX_FRAME_ID (0x287u)
#define LYNX19GW_PEL_PDO_1_TX_FRAME_ID (0x187u)
#define LYNX19GW_NR_PER_PDO_2_RX_FRAME_ID (0x305u)
#define LYNX19GW_NR_PEL_PDO_2_RX_FRAME_ID (0x307u)
#define LYNX19GW_NR_PER_PDO_1_RX_FRAME_ID (0x205u)
#define LYNX19GW_CLIENT_BMS_DATA_FRAME_ID (0xf1u)
#define LYNX19GW_BMS_CLIENT_CELL_TEMPERATURES_FRAME_ID (0xa2u)
#define LYNX19GW_BMS_CLIENT_CELL_VOLTAGES_FRAME_ID (0xa3u)
#define LYNX19GW_NF_DL_BUTTONS_RTD_FRAME_ID (0xc3u)
#define LYNX19GW_DATALOGGER_CONFIG_FRAME_ID (0x10u)
#define LYNX19GW_BMS_DL_HARTBEAT_FRAME_ID (0xafu)
#define LYNX19GW_NR_DL_HARTBEAT_FRAME_ID (0xbfu)
#define LYNX19GW_NF_DL_HARTBEAT_FRAME_ID (0xcfu)
#define LYNX19GW_BMS_DL_DATA_FRAME_ID (0xa1u)
#define LYNX19GW_NR_PEL_PDO_1_RX_FRAME_ID (0x207u)
#define LYNX19GW_NR_DL_SENSORS_3_FRAME_ID (0xb3u)
#define LYNX19GW_NR_DL_SENSORS_2_FRAME_ID (0xb2u)
#define LYNX19GW_NR_DL_SENSORS_1_FRAME_ID (0xb1u)
#define LYNX19GW_NF_NR_SENSORS_1_FRAME_ID (0xc1u)
#define LYNX19GW_NF_NR_SENSORS_2_FRAME_ID (0xc2u)

/**
 * Signals in message AS_Torque_Req.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_as_torque_req_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_set_point_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_set_point_right;
};

/**
 * Signals in message AS_DL_Sensors.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_as_dl_sensors_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t steering_position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rack_position;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_ebs_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_ebs_line;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pressure_service;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t pressure_regulator;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t as_rtd;
};

/**
 * Signals in message NR_DL_Sensors_4_NEW.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_sensors_4_new_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message NR_DL_TV_out_3_NEW.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_tv_out_3_new_t {
    /**
     * Dummy signal in empty message.
     */
    uint8_t dummy;
};

/**
 * Signals in message DL_AS_Status.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_dl_as_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_mission;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_front;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_rear;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t dl_status;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t acc_so_c;
};

/**
 * Signals in message NR_DL_TV_out_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_tv_out_2_t {
    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    uint8_t tv_out_mu;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t tv_out_sw_ang;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t tv_out_tv_l_act;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t tv_out_tv_r_act;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    int16_t tv_out_yaw_rate_ref;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_out_yrc_act;
};

/**
 * Signals in message NR_DL_TV_out_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_tv_out_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t tv_out_fz_rl;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t tv_out_fz_rr;

    /**
     * Range: -
     * Scale: 0.1
     * Offset: 0
     */
    int16_t tv_out_mz_req;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t tv_out_velocity;
};

/**
 * Signals in message DL_NR_TV_Conf_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_dl_nr_tv_conf_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_lltd_ay_scaling;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_tc_delta_th;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_tc_kgain;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_yrc_kbias;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_yrc_os_agr;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_tv_mode;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t tv_switches;
};

/**
 * Signals in message DL_NR_TV_Conf_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_dl_nr_tv_conf_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t tv_ku_stat;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t tv_pid_kp_scale;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t tv_pid_kd_scale;

    /**
     * Range: -
     * Scale: 0.01
     * Offset: 0
     */
    uint16_t tv_pid_tt_scale;
};

/**
 * Signals in message PER_PDO_1_TX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_per_pdo_1_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_engaged_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_estimate_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_estimate_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t errors_right;
};

/**
 * Signals in message PER_PDO_2_TX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_per_pdo_2_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t measured_udc_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t power_estimate_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t temperature_windings_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t temperature_inverter_right;
};

/**
 * Signals in message PEL_PDO_2_TX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_pel_pdo_2_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t power_estimate_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t measured_udc_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t temperature_windings_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t temperature_inverter_left;
};

/**
 * Signals in message PEL_PDO_1_TX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_pel_pdo_1_tx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t drive_engaged_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_estimate_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_estimate_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t errors_left;
};

/**
 * Signals in message NR_PER_PDO_2_RX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_per_pdo_2_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_drive_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_set_point_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_limit_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_reset_right;
};

/**
 * Signals in message NR_PEL_PDO_2_RX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_pel_pdo_2_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_drive_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_set_point_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_limit_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_reset_left;
};

/**
 * Signals in message NR_PER_PDO_1_RX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_per_pdo_1_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_drive_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_set_point_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_limit_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_reset_right;
};

/**
 * Signals in message Client_BMS_Data.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_client_bms_data_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_communication;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t trigger_imd;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t trigger_bms;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bms_reset;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t bms_discharge;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_discharge_threshold;
};

/**
 * Signals in message BMS_Client_Cell_Temperatures.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_bms_client_cell_temperatures_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_temparature_payload_id;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_temparature_payload_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_temparature_payload_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_temparature_payload_3;
};

/**
 * Signals in message BMS_Client_Cell_Voltages.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_bms_client_cell_voltages_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_voltage_payload_id;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_voltage_payload_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_voltage_payload_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_voltage_payload_3;
};

/**
 * Signals in message NF_DL_Buttons_RTD.
 *
 * Button presses (Datalogger-Node2
)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nf_dl_buttons_rtd_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t buttons;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t knob_l;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t knob_r;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t redy_to_drive;
};

/**
 * Signals in message Datalogger_Config.
 *
 * Configuration (Datalogger- Node12)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_datalogger_config_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t config_id;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t config_payload_1;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t config_payload_2;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t config_payload_3;
};

/**
 * Signals in message BMS_DL_Hartbeat.
 *
 * Status of AMS
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_bms_dl_hartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t bms_status;
};

/**
 * Signals in message NR_DL_Hartbeat.
 *
 * Status of Node2
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_hartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t node_2_status;
};

/**
 * Signals in message NF_DL_Hartbeat.
 *
 * Status of Node1
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nf_dl_hartbeat_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t node_1_status;
};

/**
 * Signals in message BMS_DL_Data.
 *
 * Current, Voltage, Temp (PE-Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_bms_dl_data_t {
    /**
     * Range: 0..65535 (0..65535 A)
     * Scale: 1
     * Offset: 0
     */
    uint16_t accumulator_current;

    /**
     * Range: 0..65535 (0..65535 V)
     * Scale: 1
     * Offset: 0
     */
    uint16_t accumulator_voltage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t accumulator_so_c;

    /**
     * Range: 0..65535 (0..65535 oC)
     * Scale: 1
     * Offset: 0
     */
    uint16_t accumulator_temp;
};

/**
 * Signals in message NR_PEL_PDO_1_RX.
 *
 * Torque demad to PE (Node2-PE & Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_pel_pdo_1_rx_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t enable_drive_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_set_point_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_limit_left;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t error_reset_left;
};

/**
 * Signals in message NR_DL_Sensors_3.
 *
 * Acceleration, gyro (Node2-Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_sensors_3_t {
    /**
     * Range: -32768..32767 (-327.68..327.67 m/s^2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t acceleration_x;

    /**
     * Range: -32768..32767 (-327.68..327.67 m/s^2)
     * Scale: 0.01
     * Offset: 0
     */
    int16_t acceleration_y;

    /**
     * Range: 0..200 (0..200 oC)
     * Scale: 1
     * Offset: 0
     */
    uint8_t water_temp_1;

    /**
     * Range: 0..200 (0..200 oC)
     * Scale: 1
     * Offset: 0
     */
    uint8_t water_temp_2;

    /**
     * Range: 0..200 (0..200 oC)
     * Scale: 1
     * Offset: 0
     */
    uint8_t water_temp_3;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake_rear;
};

/**
 * Signals in message NR_DL_Sensors_2.
 *
 * Disk temp, Water temp, oil temp (Node2-Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_sensors_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotor_ambient_temp_l;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotor_ambient_temp_r;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotor_object_temp_l;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t rotor_object_temp_r;

    /**
     * Range: 0..200 (0..200 0C)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gear_box_temp_l;

    /**
     * Range: 0..200 (0..200 0C)
     * Scale: 1
     * Offset: 0
     */
    uint8_t gear_box_temp_r;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int16_t yaw;
};

/**
 * Signals in message NR_DL_Sensors_1.
 *
 * Wheel speed, damper travel (Node2-Logg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nr_dl_sensors_1_t {
    /**
     * Range: 0..6000 (0..6000 mm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t damper_rl;

    /**
     * Range: 0..6000 (0..6000 mm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t damper_rr;

    /**
     * Range: 0..65535 (0..6553.5 Km/h)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t wheel_speed_rl;

    /**
     * Range: 0..65535 (0..6553.5 Km/h)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t wheel_speed_rr;
};

/**
 * Signals in message NF_NR_Sensors_1.
 *
 * Throttle, Brake, Stearing, Braketemp (Node1-Node2 & Logg)


 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nf_nr_sensors_1_t {
    /**
     * Range: 0..255 (0..255 0C)
     * Scale: 1
     * Offset: 0
     */
    uint16_t disk_temp_fl;

    /**
     * Range: 0..255 (0..255 0C)
     * Scale: 1
     * Offset: 0
     */
    uint16_t disk_temp_fr;

    /**
     * Range: -120..120 (-120..120 o)
     * Scale: 1
     * Offset: 0
     */
    int8_t steering_angle;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t brake;

    /**
     * Range: 0..100 (0..100 %)
     * Scale: 1
     * Offset: 0
     */
    uint8_t throttle;
};

/**
 * Signals in message NF_NR_Sensors_2.
 *
 * Wheel speed, damper travel (Node1-Node2 & Losgg)
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_nf_nr_sensors_2_t {
    /**
     * Range: 0..65535 (0..6553.5 Km/h)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t wheel_speed_fl;

    /**
     * Range: 0..65535 (0..6553.5 Km/h)
     * Scale: 0.1
     * Offset: 0
     */
    uint16_t wheel_speed_fr;

    /**
     * Range: 0..6000 (0..6000 mm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t damper_fl;

    /**
     * Range: 0..6000 (0..6000 mm)
     * Scale: 1
     * Offset: 0
     */
    uint16_t damper_fr;
};

/**
 * Pack message AS_Torque_Req.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_as_torque_req_pack(
    uint8_t *dst_p,
    const struct lynx19gw_as_torque_req_t *src_p,
    size_t size);

/**
 * Unpack message AS_Torque_Req.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_as_torque_req_unpack(
    struct lynx19gw_as_torque_req_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_as_torque_req_torque_set_point_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_torque_req_torque_set_point_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_torque_req_torque_set_point_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_as_torque_req_torque_set_point_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_torque_req_torque_set_point_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_torque_req_torque_set_point_right_is_in_range(uint16_t value);

/**
 * Pack message AS_DL_Sensors.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_as_dl_sensors_pack(
    uint8_t *dst_p,
    const struct lynx19gw_as_dl_sensors_t *src_p,
    size_t size);

/**
 * Unpack message AS_DL_Sensors.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_as_dl_sensors_unpack(
    struct lynx19gw_as_dl_sensors_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_dl_sensors_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_dl_sensors_steering_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_steering_position_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_steering_position_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_dl_sensors_rack_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_rack_position_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_rack_position_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_dl_sensors_pressure_ebs_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_pressure_ebs_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_pressure_ebs_act_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_dl_sensors_pressure_ebs_line_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_pressure_ebs_line_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_pressure_ebs_line_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_dl_sensors_pressure_service_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_pressure_service_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_pressure_service_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_as_dl_sensors_pressure_regulator_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_pressure_regulator_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_pressure_regulator_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_as_dl_sensors_as_rtd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_dl_sensors_as_rtd_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_dl_sensors_as_rtd_is_in_range(int8_t value);

/**
 * Pack message NR_DL_Sensors_4_NEW.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_4_new_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_4_new_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_Sensors_4_NEW.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_4_new_unpack(
    struct lynx19gw_nr_dl_sensors_4_new_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message NR_DL_TV_out_3_NEW.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_tv_out_3_new_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_tv_out_3_new_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_TV_out_3_NEW.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_tv_out_3_new_unpack(
    struct lynx19gw_nr_dl_tv_out_3_new_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Pack message DL_AS_Status.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_dl_as_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_dl_as_status_t *src_p,
    size_t size);

/**
 * Unpack message DL_AS_Status.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_dl_as_status_unpack(
    struct lynx19gw_dl_as_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_as_status_as_mission_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_as_status_as_mission_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_as_status_as_mission_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_as_status_brake_front_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_as_status_brake_front_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_as_status_brake_front_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_as_status_brake_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_as_status_brake_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_as_status_brake_rear_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_as_status_dl_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_as_status_dl_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_as_status_dl_status_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_as_status_acc_so_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_as_status_acc_so_c_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_as_status_acc_so_c_is_in_range(uint8_t value);

/**
 * Pack message NR_DL_TV_out_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_tv_out_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_tv_out_2_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_TV_out_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_tv_out_2_unpack(
    struct lynx19gw_nr_dl_tv_out_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_tv_out_2_tv_out_mu_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_2_tv_out_mu_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_2_tv_out_mu_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_nr_dl_tv_out_2_tv_out_sw_ang_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_2_tv_out_sw_ang_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_2_tv_out_sw_ang_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_nr_dl_tv_out_2_tv_out_tv_l_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_2_tv_out_tv_l_act_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_2_tv_out_tv_l_act_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_nr_dl_tv_out_2_tv_out_tv_r_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_2_tv_out_tv_r_act_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_2_tv_out_tv_r_act_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_tv_out_2_tv_out_yaw_rate_ref_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_2_tv_out_yaw_rate_ref_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_2_tv_out_yaw_rate_ref_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_tv_out_2_tv_out_yrc_act_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_2_tv_out_yrc_act_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_2_tv_out_yrc_act_is_in_range(uint8_t value);

/**
 * Pack message NR_DL_TV_out_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_tv_out_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_tv_out_1_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_TV_out_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_tv_out_1_unpack(
    struct lynx19gw_nr_dl_tv_out_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_tv_out_1_tv_out_fz_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_1_tv_out_fz_rl_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_1_tv_out_fz_rl_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_tv_out_1_tv_out_fz_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_1_tv_out_fz_rr_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_1_tv_out_fz_rr_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_tv_out_1_tv_out_mz_req_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_1_tv_out_mz_req_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_1_tv_out_mz_req_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_tv_out_1_tv_out_velocity_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_tv_out_1_tv_out_velocity_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_tv_out_1_tv_out_velocity_is_in_range(int16_t value);

/**
 * Pack message DL_NR_TV_Conf_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_dl_nr_tv_conf_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_dl_nr_tv_conf_2_t *src_p,
    size_t size);

/**
 * Unpack message DL_NR_TV_Conf_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_dl_nr_tv_conf_2_unpack(
    struct lynx19gw_dl_nr_tv_conf_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_lltd_ay_scaling_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_lltd_ay_scaling_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_lltd_ay_scaling_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_tc_delta_th_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_tc_delta_th_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_tc_delta_th_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_tc_kgain_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_tc_kgain_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_tc_kgain_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_yrc_kbias_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_yrc_kbias_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_yrc_kbias_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_yrc_os_agr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_yrc_os_agr_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_yrc_os_agr_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_tv_mode_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_tv_mode_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_tv_mode_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_dl_nr_tv_conf_2_tv_switches_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_2_tv_switches_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_2_tv_switches_is_in_range(uint8_t value);

/**
 * Pack message DL_NR_TV_Conf_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_dl_nr_tv_conf_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_dl_nr_tv_conf_1_t *src_p,
    size_t size);

/**
 * Unpack message DL_NR_TV_Conf_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_dl_nr_tv_conf_1_unpack(
    struct lynx19gw_dl_nr_tv_conf_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_dl_nr_tv_conf_1_tv_ku_stat_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_1_tv_ku_stat_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_1_tv_ku_stat_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_dl_nr_tv_conf_1_tv_pid_kp_scale_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_1_tv_pid_kp_scale_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_1_tv_pid_kp_scale_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_dl_nr_tv_conf_1_tv_pid_kd_scale_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_1_tv_pid_kd_scale_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_1_tv_pid_kd_scale_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_dl_nr_tv_conf_1_tv_pid_tt_scale_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_dl_nr_tv_conf_1_tv_pid_tt_scale_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_dl_nr_tv_conf_1_tv_pid_tt_scale_is_in_range(uint16_t value);

/**
 * Pack message PER_PDO_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_per_pdo_1_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_per_pdo_1_tx_t *src_p,
    size_t size);

/**
 * Unpack message PER_PDO_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_per_pdo_1_tx_unpack(
    struct lynx19gw_per_pdo_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_per_pdo_1_tx_drive_engaged_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_1_tx_drive_engaged_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_1_tx_drive_engaged_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_1_tx_torque_estimate_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_1_tx_torque_estimate_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_1_tx_torque_estimate_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_1_tx_speed_estimate_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_1_tx_speed_estimate_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_1_tx_speed_estimate_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_1_tx_errors_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_1_tx_errors_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_1_tx_errors_right_is_in_range(uint16_t value);

/**
 * Pack message PER_PDO_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_per_pdo_2_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_per_pdo_2_tx_t *src_p,
    size_t size);

/**
 * Unpack message PER_PDO_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_per_pdo_2_tx_unpack(
    struct lynx19gw_per_pdo_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_2_tx_measured_udc_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_2_tx_measured_udc_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_2_tx_measured_udc_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_2_tx_power_estimate_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_2_tx_power_estimate_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_2_tx_power_estimate_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_2_tx_temperature_windings_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_2_tx_temperature_windings_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_2_tx_temperature_windings_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_per_pdo_2_tx_temperature_inverter_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_per_pdo_2_tx_temperature_inverter_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_per_pdo_2_tx_temperature_inverter_right_is_in_range(uint16_t value);

/**
 * Pack message PEL_PDO_2_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_pel_pdo_2_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pel_pdo_2_tx_t *src_p,
    size_t size);

/**
 * Unpack message PEL_PDO_2_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_pel_pdo_2_tx_unpack(
    struct lynx19gw_pel_pdo_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_2_tx_power_estimate_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_2_tx_power_estimate_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_2_tx_power_estimate_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_2_tx_measured_udc_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_2_tx_measured_udc_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_2_tx_measured_udc_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_2_tx_temperature_windings_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_2_tx_temperature_windings_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_2_tx_temperature_windings_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_2_tx_temperature_inverter_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_2_tx_temperature_inverter_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_2_tx_temperature_inverter_left_is_in_range(uint16_t value);

/**
 * Pack message PEL_PDO_1_TX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_pel_pdo_1_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pel_pdo_1_tx_t *src_p,
    size_t size);

/**
 * Unpack message PEL_PDO_1_TX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_pel_pdo_1_tx_unpack(
    struct lynx19gw_pel_pdo_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_pel_pdo_1_tx_drive_engaged_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_1_tx_drive_engaged_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_1_tx_drive_engaged_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_1_tx_torque_estimate_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_1_tx_torque_estimate_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_1_tx_torque_estimate_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_1_tx_speed_estimate_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_1_tx_speed_estimate_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_1_tx_speed_estimate_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_pel_pdo_1_tx_errors_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pel_pdo_1_tx_errors_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pel_pdo_1_tx_errors_left_is_in_range(uint16_t value);

/**
 * Pack message NR_PER_PDO_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_per_pdo_2_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_per_pdo_2_rx_t *src_p,
    size_t size);

/**
 * Unpack message NR_PER_PDO_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_per_pdo_2_rx_unpack(
    struct lynx19gw_nr_per_pdo_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_per_pdo_2_rx_enable_drive_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_2_rx_enable_drive_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_2_rx_enable_drive_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_per_pdo_2_rx_torque_set_point_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_2_rx_torque_set_point_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_2_rx_torque_set_point_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_per_pdo_2_rx_speed_limit_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_2_rx_speed_limit_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_2_rx_speed_limit_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_per_pdo_2_rx_error_reset_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_2_rx_error_reset_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_2_rx_error_reset_right_is_in_range(uint16_t value);

/**
 * Pack message NR_PEL_PDO_2_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_pel_pdo_2_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_pel_pdo_2_rx_t *src_p,
    size_t size);

/**
 * Unpack message NR_PEL_PDO_2_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_pel_pdo_2_rx_unpack(
    struct lynx19gw_nr_pel_pdo_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_pel_pdo_2_rx_enable_drive_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_2_rx_enable_drive_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_2_rx_enable_drive_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_pel_pdo_2_rx_torque_set_point_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_2_rx_torque_set_point_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_2_rx_torque_set_point_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_pel_pdo_2_rx_speed_limit_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_2_rx_speed_limit_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_2_rx_speed_limit_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_pel_pdo_2_rx_error_reset_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_2_rx_error_reset_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_2_rx_error_reset_left_is_in_range(uint16_t value);

/**
 * Pack message NR_PER_PDO_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_per_pdo_1_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_per_pdo_1_rx_t *src_p,
    size_t size);

/**
 * Unpack message NR_PER_PDO_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_per_pdo_1_rx_unpack(
    struct lynx19gw_nr_per_pdo_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_per_pdo_1_rx_enable_drive_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_1_rx_enable_drive_right_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_1_rx_enable_drive_right_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_per_pdo_1_rx_torque_set_point_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_1_rx_torque_set_point_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_1_rx_torque_set_point_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_per_pdo_1_rx_speed_limit_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_1_rx_speed_limit_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_1_rx_speed_limit_right_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_per_pdo_1_rx_error_reset_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_per_pdo_1_rx_error_reset_right_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_per_pdo_1_rx_error_reset_right_is_in_range(uint16_t value);

/**
 * Pack message Client_BMS_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_client_bms_data_pack(
    uint8_t *dst_p,
    const struct lynx19gw_client_bms_data_t *src_p,
    size_t size);

/**
 * Unpack message Client_BMS_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_client_bms_data_unpack(
    struct lynx19gw_client_bms_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_client_bms_data_enable_communication_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_client_bms_data_enable_communication_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_client_bms_data_enable_communication_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_client_bms_data_trigger_imd_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_client_bms_data_trigger_imd_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_client_bms_data_trigger_imd_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_client_bms_data_trigger_bms_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_client_bms_data_trigger_bms_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_client_bms_data_trigger_bms_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_client_bms_data_bms_reset_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_client_bms_data_bms_reset_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_client_bms_data_bms_reset_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_client_bms_data_bms_discharge_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_client_bms_data_bms_discharge_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_client_bms_data_bms_discharge_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_client_bms_data_bms_discharge_threshold_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_client_bms_data_bms_discharge_threshold_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_client_bms_data_bms_discharge_threshold_is_in_range(uint16_t value);

/**
 * Pack message BMS_Client_Cell_Temperatures.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_bms_client_cell_temperatures_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_client_cell_temperatures_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Client_Cell_Temperatures.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_bms_client_cell_temperatures_unpack(
    struct lynx19gw_bms_client_cell_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_3_is_in_range(uint16_t value);

/**
 * Pack message BMS_Client_Cell_Voltages.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_bms_client_cell_voltages_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_client_cell_voltages_t *src_p,
    size_t size);

/**
 * Unpack message BMS_Client_Cell_Voltages.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_bms_client_cell_voltages_unpack(
    struct lynx19gw_bms_client_cell_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_id_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_id_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_1_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_1_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_2_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_2_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_3_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_3_is_in_range(uint16_t value);

/**
 * Pack message NF_DL_Buttons_RTD.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nf_dl_buttons_rtd_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_dl_buttons_rtd_t *src_p,
    size_t size);

/**
 * Unpack message NF_DL_Buttons_RTD.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nf_dl_buttons_rtd_unpack(
    struct lynx19gw_nf_dl_buttons_rtd_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nf_dl_buttons_rtd_buttons_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_dl_buttons_rtd_buttons_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_dl_buttons_rtd_buttons_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nf_dl_buttons_rtd_knob_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_dl_buttons_rtd_knob_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_dl_buttons_rtd_knob_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nf_dl_buttons_rtd_knob_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_dl_buttons_rtd_knob_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_dl_buttons_rtd_knob_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_nf_dl_buttons_rtd_redy_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_dl_buttons_rtd_redy_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_dl_buttons_rtd_redy_to_drive_is_in_range(int8_t value);

/**
 * Pack message Datalogger_Config.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_datalogger_config_pack(
    uint8_t *dst_p,
    const struct lynx19gw_datalogger_config_t *src_p,
    size_t size);

/**
 * Unpack message Datalogger_Config.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_datalogger_config_unpack(
    struct lynx19gw_datalogger_config_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_datalogger_config_config_id_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_datalogger_config_config_id_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_datalogger_config_config_id_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_datalogger_config_config_payload_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_datalogger_config_config_payload_1_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_datalogger_config_config_payload_1_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_datalogger_config_config_payload_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_datalogger_config_config_payload_2_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_datalogger_config_config_payload_2_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_datalogger_config_config_payload_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_datalogger_config_config_payload_3_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_datalogger_config_config_payload_3_is_in_range(int16_t value);

/**
 * Pack message BMS_DL_Hartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_bms_dl_hartbeat_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_dl_hartbeat_t *src_p,
    size_t size);

/**
 * Unpack message BMS_DL_Hartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_bms_dl_hartbeat_unpack(
    struct lynx19gw_bms_dl_hartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_dl_hartbeat_bms_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_dl_hartbeat_bms_status_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_dl_hartbeat_bms_status_is_in_range(uint16_t value);

/**
 * Pack message NR_DL_Hartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_hartbeat_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_hartbeat_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_Hartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_hartbeat_unpack(
    struct lynx19gw_nr_dl_hartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_hartbeat_node_2_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_hartbeat_node_2_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_hartbeat_node_2_status_is_in_range(uint8_t value);

/**
 * Pack message NF_DL_Hartbeat.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nf_dl_hartbeat_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_dl_hartbeat_t *src_p,
    size_t size);

/**
 * Unpack message NF_DL_Hartbeat.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nf_dl_hartbeat_unpack(
    struct lynx19gw_nf_dl_hartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nf_dl_hartbeat_node_1_status_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_dl_hartbeat_node_1_status_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_dl_hartbeat_node_1_status_is_in_range(uint8_t value);

/**
 * Pack message BMS_DL_Data.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_bms_dl_data_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_dl_data_t *src_p,
    size_t size);

/**
 * Unpack message BMS_DL_Data.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_bms_dl_data_unpack(
    struct lynx19gw_bms_dl_data_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_dl_data_accumulator_current_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_dl_data_accumulator_current_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_dl_data_accumulator_current_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_dl_data_accumulator_voltage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_dl_data_accumulator_voltage_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_dl_data_accumulator_voltage_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_dl_data_accumulator_so_c_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_dl_data_accumulator_so_c_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_dl_data_accumulator_so_c_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_bms_dl_data_accumulator_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_bms_dl_data_accumulator_temp_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_bms_dl_data_accumulator_temp_is_in_range(uint16_t value);

/**
 * Pack message NR_PEL_PDO_1_RX.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_pel_pdo_1_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_pel_pdo_1_rx_t *src_p,
    size_t size);

/**
 * Unpack message NR_PEL_PDO_1_RX.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_pel_pdo_1_rx_unpack(
    struct lynx19gw_nr_pel_pdo_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_pel_pdo_1_rx_enable_drive_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_1_rx_enable_drive_left_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_1_rx_enable_drive_left_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_pel_pdo_1_rx_torque_set_point_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_1_rx_torque_set_point_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_1_rx_torque_set_point_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_pel_pdo_1_rx_speed_limit_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_1_rx_speed_limit_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_1_rx_speed_limit_left_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_pel_pdo_1_rx_error_reset_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_pel_pdo_1_rx_error_reset_left_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_pel_pdo_1_rx_error_reset_left_is_in_range(uint16_t value);

/**
 * Pack message NR_DL_Sensors_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_3_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_Sensors_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_3_unpack(
    struct lynx19gw_nr_dl_sensors_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_sensors_3_acceleration_x_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_3_acceleration_x_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_3_acceleration_x_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_sensors_3_acceleration_y_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_3_acceleration_y_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_3_acceleration_y_is_in_range(int16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_3_water_temp_1_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_3_water_temp_1_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_3_water_temp_1_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_3_water_temp_2_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_3_water_temp_2_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_3_water_temp_2_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_3_water_temp_3_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_3_water_temp_3_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_3_water_temp_3_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_3_brake_rear_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_3_brake_rear_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_3_brake_rear_is_in_range(uint8_t value);

/**
 * Pack message NR_DL_Sensors_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_2_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_Sensors_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_2_unpack(
    struct lynx19gw_nr_dl_sensors_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_2_rotor_object_temp_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_rotor_object_temp_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_rotor_object_temp_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_2_rotor_object_temp_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_rotor_object_temp_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_rotor_object_temp_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_2_gear_box_temp_l_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_gear_box_temp_l_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_gear_box_temp_l_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nr_dl_sensors_2_gear_box_temp_r_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_gear_box_temp_r_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_gear_box_temp_r_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int16_t lynx19gw_nr_dl_sensors_2_yaw_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_2_yaw_decode(int16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_2_yaw_is_in_range(int16_t value);

/**
 * Pack message NR_DL_Sensors_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_1_t *src_p,
    size_t size);

/**
 * Unpack message NR_DL_Sensors_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nr_dl_sensors_1_unpack(
    struct lynx19gw_nr_dl_sensors_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_dl_sensors_1_damper_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_1_damper_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_1_damper_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_dl_sensors_1_damper_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_1_damper_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_1_damper_rr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_dl_sensors_1_wheel_speed_rl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_1_wheel_speed_rl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_1_wheel_speed_rl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nr_dl_sensors_1_wheel_speed_rr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nr_dl_sensors_1_wheel_speed_rr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nr_dl_sensors_1_wheel_speed_rr_is_in_range(uint16_t value);

/**
 * Pack message NF_NR_Sensors_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nf_nr_sensors_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_nr_sensors_1_t *src_p,
    size_t size);

/**
 * Unpack message NF_NR_Sensors_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nf_nr_sensors_1_unpack(
    struct lynx19gw_nf_nr_sensors_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nf_nr_sensors_1_disk_temp_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_1_disk_temp_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_1_disk_temp_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nf_nr_sensors_1_disk_temp_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_1_disk_temp_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_1_disk_temp_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_nf_nr_sensors_1_steering_angle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_1_steering_angle_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_1_steering_angle_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nf_nr_sensors_1_brake_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_1_brake_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_1_brake_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_nf_nr_sensors_1_throttle_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_1_throttle_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_1_throttle_is_in_range(uint8_t value);

/**
 * Pack message NF_NR_Sensors_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_nf_nr_sensors_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_nr_sensors_2_t *src_p,
    size_t size);

/**
 * Unpack message NF_NR_Sensors_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_nf_nr_sensors_2_unpack(
    struct lynx19gw_nf_nr_sensors_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nf_nr_sensors_2_wheel_speed_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_2_wheel_speed_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_2_wheel_speed_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nf_nr_sensors_2_wheel_speed_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_2_wheel_speed_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_2_wheel_speed_fr_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nf_nr_sensors_2_damper_fl_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_2_damper_fl_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_2_damper_fl_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_nf_nr_sensors_2_damper_fr_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_nf_nr_sensors_2_damper_fr_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_nf_nr_sensors_2_damper_fr_is_in_range(uint16_t value);

#endif
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Thu May  7 12:29:31 2020.
 */

#include <string.h>

//#include "lynx19gw.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

int lynx19gw_as_torque_req_pack(
    uint8_t *dst_p,
    const struct lynx19gw_as_torque_req_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->torque_set_point_left, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->torque_set_point_left, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->torque_set_point_right, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->torque_set_point_right, 8u, 0xffu);

    return (8);
}

int lynx19gw_as_torque_req_unpack(
    struct lynx19gw_as_torque_req_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->torque_set_point_left |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->torque_set_point_left |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->torque_set_point_right |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->torque_set_point_right |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_as_torque_req_torque_set_point_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_as_torque_req_torque_set_point_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_as_torque_req_torque_set_point_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_as_torque_req_torque_set_point_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_as_torque_req_torque_set_point_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_as_torque_req_torque_set_point_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_as_dl_sensors_pack(
    uint8_t *dst_p,
    const struct lynx19gw_as_dl_sensors_t *src_p,
    size_t size)
{
    uint8_t as_rtd;
    uint8_t pressure_regulator;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->as_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->steering_position, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->rack_position, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->pressure_ebs_act, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->pressure_ebs_line, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->pressure_service, 0u, 0xffu);
    pressure_regulator = (uint8_t)src_p->pressure_regulator;
    dst_p[6] |= pack_left_shift_u8(pressure_regulator, 0u, 0xffu);
    as_rtd = (uint8_t)src_p->as_rtd;
    dst_p[7] |= pack_left_shift_u8(as_rtd, 0u, 0xffu);

    return (8);
}

int lynx19gw_as_dl_sensors_unpack(
    struct lynx19gw_as_dl_sensors_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t as_rtd;
    uint8_t pressure_regulator;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->as_state |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->steering_position |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->rack_position |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->pressure_ebs_act |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->pressure_ebs_line |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->pressure_service |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    pressure_regulator = 0u;
    pressure_regulator |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->pressure_regulator = (int8_t)pressure_regulator;
    as_rtd = 0u;
    as_rtd |= unpack_right_shift_u8(src_p[7], 0u, 0xffu);
    dst_p->as_rtd = (int8_t)as_rtd;

    return (0);
}

uint8_t lynx19gw_as_dl_sensors_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_dl_sensors_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_as_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_as_dl_sensors_steering_position_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_dl_sensors_steering_position_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_steering_position_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_as_dl_sensors_rack_position_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_dl_sensors_rack_position_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_rack_position_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_as_dl_sensors_pressure_ebs_act_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_dl_sensors_pressure_ebs_act_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_pressure_ebs_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_as_dl_sensors_pressure_ebs_line_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_dl_sensors_pressure_ebs_line_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_pressure_ebs_line_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_as_dl_sensors_pressure_service_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_dl_sensors_pressure_service_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_pressure_service_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_as_dl_sensors_pressure_regulator_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_as_dl_sensors_pressure_regulator_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_pressure_regulator_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_as_dl_sensors_as_rtd_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_as_dl_sensors_as_rtd_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_dl_sensors_as_rtd_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_sensors_4_new_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_4_new_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int lynx19gw_nr_dl_sensors_4_new_unpack(
    struct lynx19gw_nr_dl_sensors_4_new_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    return (0);
}

int lynx19gw_nr_dl_tv_out_3_new_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_tv_out_3_new_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    return (8);
}

int lynx19gw_nr_dl_tv_out_3_new_unpack(
    struct lynx19gw_nr_dl_tv_out_3_new_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    (void)src_p;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    return (0);
}

int lynx19gw_dl_as_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_dl_as_status_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    dst_p[0] |= pack_left_shift_u8(src_p->as_mission, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->brake_front, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->brake_rear, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->dl_status, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->acc_so_c, 0u, 0xffu);

    return (5);
}

int lynx19gw_dl_as_status_unpack(
    struct lynx19gw_dl_as_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 5u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->as_mission |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->brake_front |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->brake_rear |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->dl_status |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->acc_so_c |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_dl_as_status_as_mission_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_as_status_as_mission_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_as_status_as_mission_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_as_status_brake_front_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_as_status_brake_front_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_as_status_brake_front_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_as_status_brake_rear_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_as_status_brake_rear_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_as_status_brake_rear_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_as_status_dl_status_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_as_status_dl_status_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_as_status_dl_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_as_status_acc_so_c_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_as_status_acc_so_c_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_as_status_acc_so_c_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_tv_out_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_tv_out_2_t *src_p,
    size_t size)
{
    uint16_t tv_out_yaw_rate_ref;
    uint8_t tv_out_sw_ang;
    uint8_t tv_out_tv_l_act;
    uint8_t tv_out_tv_r_act;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->tv_out_mu, 0u, 0xffu);
    tv_out_sw_ang = (uint8_t)src_p->tv_out_sw_ang;
    dst_p[1] |= pack_left_shift_u8(tv_out_sw_ang, 0u, 0xffu);
    tv_out_tv_l_act = (uint8_t)src_p->tv_out_tv_l_act;
    dst_p[2] |= pack_left_shift_u8(tv_out_tv_l_act, 0u, 0xffu);
    tv_out_tv_r_act = (uint8_t)src_p->tv_out_tv_r_act;
    dst_p[3] |= pack_left_shift_u8(tv_out_tv_r_act, 0u, 0xffu);
    tv_out_yaw_rate_ref = (uint16_t)src_p->tv_out_yaw_rate_ref;
    dst_p[4] |= pack_left_shift_u16(tv_out_yaw_rate_ref, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(tv_out_yaw_rate_ref, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->tv_out_yrc_act, 0u, 0xffu);

    return (7);
}

int lynx19gw_nr_dl_tv_out_2_unpack(
    struct lynx19gw_nr_dl_tv_out_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t tv_out_yaw_rate_ref;
    uint8_t tv_out_sw_ang;
    uint8_t tv_out_tv_l_act;
    uint8_t tv_out_tv_r_act;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->tv_out_mu |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    tv_out_sw_ang = 0u;
    tv_out_sw_ang |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->tv_out_sw_ang = (int8_t)tv_out_sw_ang;
    tv_out_tv_l_act = 0u;
    tv_out_tv_l_act |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->tv_out_tv_l_act = (int8_t)tv_out_tv_l_act;
    tv_out_tv_r_act = 0u;
    tv_out_tv_r_act |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->tv_out_tv_r_act = (int8_t)tv_out_tv_r_act;
    tv_out_yaw_rate_ref = 0u;
    tv_out_yaw_rate_ref |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    tv_out_yaw_rate_ref |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->tv_out_yaw_rate_ref = (int16_t)tv_out_yaw_rate_ref;
    dst_p->tv_out_yrc_act |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nr_dl_tv_out_2_tv_out_mu_encode(double value)
{
    return (uint8_t)(value / 0.1);
}

double lynx19gw_nr_dl_tv_out_2_tv_out_mu_decode(uint8_t value)
{
    return ((double)value * 0.1);
}

bool lynx19gw_nr_dl_tv_out_2_tv_out_mu_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_nr_dl_tv_out_2_tv_out_sw_ang_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_nr_dl_tv_out_2_tv_out_sw_ang_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_2_tv_out_sw_ang_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_nr_dl_tv_out_2_tv_out_tv_l_act_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_nr_dl_tv_out_2_tv_out_tv_l_act_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_2_tv_out_tv_l_act_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_nr_dl_tv_out_2_tv_out_tv_r_act_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_nr_dl_tv_out_2_tv_out_tv_r_act_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_2_tv_out_tv_r_act_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_nr_dl_tv_out_2_tv_out_yaw_rate_ref_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double lynx19gw_nr_dl_tv_out_2_tv_out_yaw_rate_ref_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool lynx19gw_nr_dl_tv_out_2_tv_out_yaw_rate_ref_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nr_dl_tv_out_2_tv_out_yrc_act_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_tv_out_2_tv_out_yrc_act_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_2_tv_out_yrc_act_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_tv_out_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_tv_out_1_t *src_p,
    size_t size)
{
    uint16_t tv_out_fz_rl;
    uint16_t tv_out_fz_rr;
    uint16_t tv_out_mz_req;
    uint16_t tv_out_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    tv_out_fz_rl = (uint16_t)src_p->tv_out_fz_rl;
    dst_p[0] |= pack_left_shift_u16(tv_out_fz_rl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(tv_out_fz_rl, 8u, 0xffu);
    tv_out_fz_rr = (uint16_t)src_p->tv_out_fz_rr;
    dst_p[2] |= pack_left_shift_u16(tv_out_fz_rr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(tv_out_fz_rr, 8u, 0xffu);
    tv_out_mz_req = (uint16_t)src_p->tv_out_mz_req;
    dst_p[4] |= pack_left_shift_u16(tv_out_mz_req, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(tv_out_mz_req, 8u, 0xffu);
    tv_out_velocity = (uint16_t)src_p->tv_out_velocity;
    dst_p[6] |= pack_left_shift_u16(tv_out_velocity, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(tv_out_velocity, 8u, 0xffu);

    return (8);
}

int lynx19gw_nr_dl_tv_out_1_unpack(
    struct lynx19gw_nr_dl_tv_out_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t tv_out_fz_rl;
    uint16_t tv_out_fz_rr;
    uint16_t tv_out_mz_req;
    uint16_t tv_out_velocity;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    tv_out_fz_rl = 0u;
    tv_out_fz_rl |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    tv_out_fz_rl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->tv_out_fz_rl = (int16_t)tv_out_fz_rl;
    tv_out_fz_rr = 0u;
    tv_out_fz_rr |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    tv_out_fz_rr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->tv_out_fz_rr = (int16_t)tv_out_fz_rr;
    tv_out_mz_req = 0u;
    tv_out_mz_req |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    tv_out_mz_req |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->tv_out_mz_req = (int16_t)tv_out_mz_req;
    tv_out_velocity = 0u;
    tv_out_velocity |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    tv_out_velocity |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->tv_out_velocity = (int16_t)tv_out_velocity;

    return (0);
}

int16_t lynx19gw_nr_dl_tv_out_1_tv_out_fz_rl_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_nr_dl_tv_out_1_tv_out_fz_rl_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_1_tv_out_fz_rl_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_nr_dl_tv_out_1_tv_out_fz_rr_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_nr_dl_tv_out_1_tv_out_fz_rr_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_1_tv_out_fz_rr_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_nr_dl_tv_out_1_tv_out_mz_req_encode(double value)
{
    return (int16_t)(value / 0.1);
}

double lynx19gw_nr_dl_tv_out_1_tv_out_mz_req_decode(int16_t value)
{
    return ((double)value * 0.1);
}

bool lynx19gw_nr_dl_tv_out_1_tv_out_mz_req_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_nr_dl_tv_out_1_tv_out_velocity_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_nr_dl_tv_out_1_tv_out_velocity_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_tv_out_1_tv_out_velocity_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_dl_nr_tv_conf_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_dl_nr_tv_conf_2_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->tv_lltd_ay_scaling, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->tv_tc_delta_th, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->tv_tc_kgain, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->tv_yrc_kbias, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->tv_yrc_os_agr, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->tv_tv_mode, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->tv_switches, 0u, 0xffu);

    return (7);
}

int lynx19gw_dl_nr_tv_conf_2_unpack(
    struct lynx19gw_dl_nr_tv_conf_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->tv_lltd_ay_scaling |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->tv_tc_delta_th |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->tv_tc_kgain |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->tv_yrc_kbias |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->tv_yrc_os_agr |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->tv_tv_mode |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->tv_switches |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_lltd_ay_scaling_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_lltd_ay_scaling_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_lltd_ay_scaling_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_tc_delta_th_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_tc_delta_th_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_tc_delta_th_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_tc_kgain_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_tc_kgain_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_tc_kgain_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_yrc_kbias_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_yrc_kbias_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_yrc_kbias_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_yrc_os_agr_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_yrc_os_agr_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_yrc_os_agr_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_tv_mode_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_tv_mode_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_tv_mode_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_dl_nr_tv_conf_2_tv_switches_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_dl_nr_tv_conf_2_tv_switches_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_2_tv_switches_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_dl_nr_tv_conf_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_dl_nr_tv_conf_1_t *src_p,
    size_t size)
{
    uint16_t tv_ku_stat;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    tv_ku_stat = (uint16_t)src_p->tv_ku_stat;
    dst_p[0] |= pack_left_shift_u16(tv_ku_stat, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(tv_ku_stat, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->tv_pid_kp_scale, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->tv_pid_kp_scale, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->tv_pid_kd_scale, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->tv_pid_kd_scale, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->tv_pid_tt_scale, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->tv_pid_tt_scale, 8u, 0xffu);

    return (8);
}

int lynx19gw_dl_nr_tv_conf_1_unpack(
    struct lynx19gw_dl_nr_tv_conf_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t tv_ku_stat;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    tv_ku_stat = 0u;
    tv_ku_stat |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    tv_ku_stat |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->tv_ku_stat = (int16_t)tv_ku_stat;
    dst_p->tv_pid_kp_scale |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->tv_pid_kp_scale |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->tv_pid_kd_scale |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->tv_pid_kd_scale |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->tv_pid_tt_scale |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->tv_pid_tt_scale |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

int16_t lynx19gw_dl_nr_tv_conf_1_tv_ku_stat_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_dl_nr_tv_conf_1_tv_ku_stat_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_dl_nr_tv_conf_1_tv_ku_stat_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_dl_nr_tv_conf_1_tv_pid_kp_scale_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double lynx19gw_dl_nr_tv_conf_1_tv_pid_kp_scale_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool lynx19gw_dl_nr_tv_conf_1_tv_pid_kp_scale_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_dl_nr_tv_conf_1_tv_pid_kd_scale_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double lynx19gw_dl_nr_tv_conf_1_tv_pid_kd_scale_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool lynx19gw_dl_nr_tv_conf_1_tv_pid_kd_scale_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_dl_nr_tv_conf_1_tv_pid_tt_scale_encode(double value)
{
    return (uint16_t)(value / 0.01);
}

double lynx19gw_dl_nr_tv_conf_1_tv_pid_tt_scale_decode(uint16_t value)
{
    return ((double)value * 0.01);
}

bool lynx19gw_dl_nr_tv_conf_1_tv_pid_tt_scale_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_per_pdo_1_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_per_pdo_1_tx_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->drive_engaged_right, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_estimate_right, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_estimate_right, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_estimate_right, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_estimate_right, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->errors_right, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->errors_right, 8u, 0xffu);

    return (7);
}

int lynx19gw_per_pdo_1_tx_unpack(
    struct lynx19gw_per_pdo_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->drive_engaged_right |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_estimate_right |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_estimate_right |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_estimate_right |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_estimate_right |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->errors_right |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->errors_right |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_per_pdo_1_tx_drive_engaged_right_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_per_pdo_1_tx_drive_engaged_right_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_1_tx_drive_engaged_right_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_per_pdo_1_tx_torque_estimate_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_1_tx_torque_estimate_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_1_tx_torque_estimate_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_per_pdo_1_tx_speed_estimate_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_1_tx_speed_estimate_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_1_tx_speed_estimate_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_per_pdo_1_tx_errors_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_1_tx_errors_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_1_tx_errors_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_per_pdo_2_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_per_pdo_2_tx_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->measured_udc_right, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->measured_udc_right, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->power_estimate_right, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->power_estimate_right, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->temperature_windings_right, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->temperature_windings_right, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->temperature_inverter_right, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->temperature_inverter_right, 8u, 0xffu);

    return (8);
}

int lynx19gw_per_pdo_2_tx_unpack(
    struct lynx19gw_per_pdo_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->measured_udc_right |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->measured_udc_right |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->power_estimate_right |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->power_estimate_right |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->temperature_windings_right |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->temperature_windings_right |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->temperature_inverter_right |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->temperature_inverter_right |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_per_pdo_2_tx_measured_udc_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_2_tx_measured_udc_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_2_tx_measured_udc_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_per_pdo_2_tx_power_estimate_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_2_tx_power_estimate_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_2_tx_power_estimate_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_per_pdo_2_tx_temperature_windings_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_2_tx_temperature_windings_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_2_tx_temperature_windings_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_per_pdo_2_tx_temperature_inverter_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_per_pdo_2_tx_temperature_inverter_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_per_pdo_2_tx_temperature_inverter_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_pel_pdo_2_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pel_pdo_2_tx_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->power_estimate_left, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->power_estimate_left, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->measured_udc_left, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->measured_udc_left, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->temperature_windings_left, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->temperature_windings_left, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->temperature_inverter_left, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->temperature_inverter_left, 8u, 0xffu);

    return (8);
}

int lynx19gw_pel_pdo_2_tx_unpack(
    struct lynx19gw_pel_pdo_2_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->power_estimate_left |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->power_estimate_left |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->measured_udc_left |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->measured_udc_left |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->temperature_windings_left |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->temperature_windings_left |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->temperature_inverter_left |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->temperature_inverter_left |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_pel_pdo_2_tx_power_estimate_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_2_tx_power_estimate_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_2_tx_power_estimate_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_pel_pdo_2_tx_measured_udc_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_2_tx_measured_udc_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_2_tx_measured_udc_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_pel_pdo_2_tx_temperature_windings_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_2_tx_temperature_windings_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_2_tx_temperature_windings_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_pel_pdo_2_tx_temperature_inverter_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_2_tx_temperature_inverter_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_2_tx_temperature_inverter_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_pel_pdo_1_tx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pel_pdo_1_tx_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->drive_engaged_left, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_estimate_left, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_estimate_left, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_estimate_left, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_estimate_left, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->errors_left, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->errors_left, 8u, 0xffu);

    return (7);
}

int lynx19gw_pel_pdo_1_tx_unpack(
    struct lynx19gw_pel_pdo_1_tx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->drive_engaged_left |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_estimate_left |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_estimate_left |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_estimate_left |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_estimate_left |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->errors_left |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->errors_left |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_pel_pdo_1_tx_drive_engaged_left_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_pel_pdo_1_tx_drive_engaged_left_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_1_tx_drive_engaged_left_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_pel_pdo_1_tx_torque_estimate_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_1_tx_torque_estimate_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_1_tx_torque_estimate_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_pel_pdo_1_tx_speed_estimate_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_1_tx_speed_estimate_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_1_tx_speed_estimate_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_pel_pdo_1_tx_errors_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_pel_pdo_1_tx_errors_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_pel_pdo_1_tx_errors_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_per_pdo_2_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_per_pdo_2_rx_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_drive_right, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_set_point_right, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_set_point_right, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_limit_right, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_limit_right, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->error_reset_right, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->error_reset_right, 8u, 0xffu);

    return (7);
}

int lynx19gw_nr_per_pdo_2_rx_unpack(
    struct lynx19gw_nr_per_pdo_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->enable_drive_right |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_set_point_right |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_set_point_right |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_limit_right |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_limit_right |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->error_reset_right |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->error_reset_right |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nr_per_pdo_2_rx_enable_drive_right_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_per_pdo_2_rx_enable_drive_right_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_2_rx_enable_drive_right_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_per_pdo_2_rx_torque_set_point_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_per_pdo_2_rx_torque_set_point_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_2_rx_torque_set_point_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_per_pdo_2_rx_speed_limit_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_per_pdo_2_rx_speed_limit_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_2_rx_speed_limit_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_per_pdo_2_rx_error_reset_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_per_pdo_2_rx_error_reset_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_2_rx_error_reset_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_pel_pdo_2_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_pel_pdo_2_rx_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_drive_left, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_set_point_left, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_set_point_left, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_limit_left, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_limit_left, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->error_reset_left, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->error_reset_left, 8u, 0xffu);

    return (7);
}

int lynx19gw_nr_pel_pdo_2_rx_unpack(
    struct lynx19gw_nr_pel_pdo_2_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->enable_drive_left |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_set_point_left |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_set_point_left |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_limit_left |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_limit_left |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->error_reset_left |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->error_reset_left |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nr_pel_pdo_2_rx_enable_drive_left_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_pel_pdo_2_rx_enable_drive_left_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_2_rx_enable_drive_left_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_pel_pdo_2_rx_torque_set_point_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_pel_pdo_2_rx_torque_set_point_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_2_rx_torque_set_point_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_pel_pdo_2_rx_speed_limit_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_pel_pdo_2_rx_speed_limit_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_2_rx_speed_limit_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_pel_pdo_2_rx_error_reset_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_pel_pdo_2_rx_error_reset_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_2_rx_error_reset_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_per_pdo_1_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_per_pdo_1_rx_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_drive_right, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_set_point_right, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_set_point_right, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_limit_right, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_limit_right, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->error_reset_right, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->error_reset_right, 8u, 0xffu);

    return (7);
}

int lynx19gw_nr_per_pdo_1_rx_unpack(
    struct lynx19gw_nr_per_pdo_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->enable_drive_right |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_set_point_right |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_set_point_right |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_limit_right |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_limit_right |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->error_reset_right |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->error_reset_right |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nr_per_pdo_1_rx_enable_drive_right_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_per_pdo_1_rx_enable_drive_right_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_1_rx_enable_drive_right_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_per_pdo_1_rx_torque_set_point_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_per_pdo_1_rx_torque_set_point_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_1_rx_torque_set_point_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_per_pdo_1_rx_speed_limit_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_per_pdo_1_rx_speed_limit_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_1_rx_speed_limit_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_per_pdo_1_rx_error_reset_right_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_per_pdo_1_rx_error_reset_right_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_per_pdo_1_rx_error_reset_right_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_client_bms_data_pack(
    uint8_t *dst_p,
    const struct lynx19gw_client_bms_data_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_communication, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->trigger_imd, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->trigger_bms, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->bms_reset, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->bms_discharge, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->bms_discharge_threshold, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->bms_discharge_threshold, 8u, 0xffu);

    return (7);
}

int lynx19gw_client_bms_data_unpack(
    struct lynx19gw_client_bms_data_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->enable_communication |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->trigger_imd |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->trigger_bms |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->bms_reset |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->bms_discharge |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->bms_discharge_threshold |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->bms_discharge_threshold |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_client_bms_data_enable_communication_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_client_bms_data_enable_communication_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_client_bms_data_enable_communication_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_client_bms_data_trigger_imd_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_client_bms_data_trigger_imd_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_client_bms_data_trigger_imd_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_client_bms_data_trigger_bms_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_client_bms_data_trigger_bms_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_client_bms_data_trigger_bms_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_client_bms_data_bms_reset_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_client_bms_data_bms_reset_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_client_bms_data_bms_reset_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_client_bms_data_bms_discharge_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_client_bms_data_bms_discharge_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_client_bms_data_bms_discharge_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_client_bms_data_bms_discharge_threshold_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_client_bms_data_bms_discharge_threshold_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_client_bms_data_bms_discharge_threshold_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_bms_client_cell_temperatures_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_client_cell_temperatures_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->bms_temparature_payload_id, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->bms_temparature_payload_id, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->bms_temparature_payload_1, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->bms_temparature_payload_1, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->bms_temparature_payload_2, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->bms_temparature_payload_2, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->bms_temparature_payload_3, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->bms_temparature_payload_3, 8u, 0xffu);

    return (8);
}

int lynx19gw_bms_client_cell_temperatures_unpack(
    struct lynx19gw_bms_client_cell_temperatures_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->bms_temparature_payload_id |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->bms_temparature_payload_id |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->bms_temparature_payload_1 |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->bms_temparature_payload_1 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->bms_temparature_payload_2 |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->bms_temparature_payload_2 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->bms_temparature_payload_3 |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->bms_temparature_payload_3 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_id_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_id_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_id_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_1_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_1_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_2_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_2_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_3_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_3_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_temperatures_bms_temparature_payload_3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_bms_client_cell_voltages_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_client_cell_voltages_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->bms_voltage_payload_id, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->bms_voltage_payload_id, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->bms_voltage_payload_1, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->bms_voltage_payload_1, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->bms_voltage_payload_2, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->bms_voltage_payload_2, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->bms_voltage_payload_3, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->bms_voltage_payload_3, 8u, 0xffu);

    return (8);
}

int lynx19gw_bms_client_cell_voltages_unpack(
    struct lynx19gw_bms_client_cell_voltages_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->bms_voltage_payload_id |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->bms_voltage_payload_id |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->bms_voltage_payload_1 |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->bms_voltage_payload_1 |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->bms_voltage_payload_2 |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->bms_voltage_payload_2 |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->bms_voltage_payload_3 |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->bms_voltage_payload_3 |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_id_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_id_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_id_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_1_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_1_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_1_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_2_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_2_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_2_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_client_cell_voltages_bms_voltage_payload_3_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_client_cell_voltages_bms_voltage_payload_3_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_client_cell_voltages_bms_voltage_payload_3_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nf_dl_buttons_rtd_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_dl_buttons_rtd_t *src_p,
    size_t size)
{
    uint8_t redy_to_drive;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    dst_p[0] |= pack_left_shift_u8(src_p->buttons, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->knob_l, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->knob_r, 0u, 0xffu);
    redy_to_drive = (uint8_t)src_p->redy_to_drive;
    dst_p[3] |= pack_left_shift_u8(redy_to_drive, 0u, 0xffu);

    return (4);
}

int lynx19gw_nf_dl_buttons_rtd_unpack(
    struct lynx19gw_nf_dl_buttons_rtd_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t redy_to_drive;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->buttons |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->knob_l |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->knob_r |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    redy_to_drive = 0u;
    redy_to_drive |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->redy_to_drive = (int8_t)redy_to_drive;

    return (0);
}

uint8_t lynx19gw_nf_dl_buttons_rtd_buttons_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nf_dl_buttons_rtd_buttons_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_dl_buttons_rtd_buttons_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nf_dl_buttons_rtd_knob_l_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nf_dl_buttons_rtd_knob_l_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_dl_buttons_rtd_knob_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nf_dl_buttons_rtd_knob_r_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nf_dl_buttons_rtd_knob_r_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_dl_buttons_rtd_knob_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_nf_dl_buttons_rtd_redy_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_nf_dl_buttons_rtd_redy_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_dl_buttons_rtd_redy_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_datalogger_config_pack(
    uint8_t *dst_p,
    const struct lynx19gw_datalogger_config_t *src_p,
    size_t size)
{
    uint16_t config_payload_1;
    uint16_t config_payload_2;
    uint16_t config_payload_3;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->config_id, 0u, 0xffu);
    config_payload_1 = (uint16_t)src_p->config_payload_1;
    dst_p[1] |= pack_left_shift_u16(config_payload_1, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(config_payload_1, 8u, 0xffu);
    config_payload_2 = (uint16_t)src_p->config_payload_2;
    dst_p[3] |= pack_left_shift_u16(config_payload_2, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(config_payload_2, 8u, 0xffu);
    config_payload_3 = (uint16_t)src_p->config_payload_3;
    dst_p[5] |= pack_left_shift_u16(config_payload_3, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(config_payload_3, 8u, 0xffu);

    return (8);
}

int lynx19gw_datalogger_config_unpack(
    struct lynx19gw_datalogger_config_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t config_payload_1;
    uint16_t config_payload_2;
    uint16_t config_payload_3;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->config_id |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    config_payload_1 = 0u;
    config_payload_1 |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    config_payload_1 |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->config_payload_1 = (int16_t)config_payload_1;
    config_payload_2 = 0u;
    config_payload_2 |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    config_payload_2 |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->config_payload_2 = (int16_t)config_payload_2;
    config_payload_3 = 0u;
    config_payload_3 |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    config_payload_3 |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);
    dst_p->config_payload_3 = (int16_t)config_payload_3;

    return (0);
}

uint8_t lynx19gw_datalogger_config_config_id_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_datalogger_config_config_id_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_datalogger_config_config_id_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_datalogger_config_config_payload_1_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_datalogger_config_config_payload_1_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_datalogger_config_config_payload_1_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_datalogger_config_config_payload_2_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_datalogger_config_config_payload_2_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_datalogger_config_config_payload_2_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_datalogger_config_config_payload_3_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_datalogger_config_config_payload_3_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_datalogger_config_config_payload_3_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_bms_dl_hartbeat_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_dl_hartbeat_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->bms_status, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->bms_status, 8u, 0xffu);

    return (8);
}

int lynx19gw_bms_dl_hartbeat_unpack(
    struct lynx19gw_bms_dl_hartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->bms_status |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->bms_status |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_bms_dl_hartbeat_bms_status_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_dl_hartbeat_bms_status_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_dl_hartbeat_bms_status_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_hartbeat_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_hartbeat_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->node_2_status, 0u, 0xffu);

    return (1);
}

int lynx19gw_nr_dl_hartbeat_unpack(
    struct lynx19gw_nr_dl_hartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->node_2_status |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nr_dl_hartbeat_node_2_status_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_hartbeat_node_2_status_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_hartbeat_node_2_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nf_dl_hartbeat_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_dl_hartbeat_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->node_1_status, 0u, 0xffu);

    return (1);
}

int lynx19gw_nf_dl_hartbeat_unpack(
    struct lynx19gw_nf_dl_hartbeat_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->node_1_status |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nf_dl_hartbeat_node_1_status_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nf_dl_hartbeat_node_1_status_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_dl_hartbeat_node_1_status_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_bms_dl_data_pack(
    uint8_t *dst_p,
    const struct lynx19gw_bms_dl_data_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->accumulator_current, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->accumulator_current, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->accumulator_voltage, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->accumulator_voltage, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->accumulator_so_c, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->accumulator_so_c, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->accumulator_temp, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->accumulator_temp, 8u, 0xffu);

    return (8);
}

int lynx19gw_bms_dl_data_unpack(
    struct lynx19gw_bms_dl_data_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->accumulator_current |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->accumulator_current |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->accumulator_voltage |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->accumulator_voltage |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->accumulator_so_c |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->accumulator_so_c |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->accumulator_temp |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->accumulator_temp |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_bms_dl_data_accumulator_current_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_dl_data_accumulator_current_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_dl_data_accumulator_current_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_dl_data_accumulator_voltage_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_dl_data_accumulator_voltage_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_dl_data_accumulator_voltage_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_dl_data_accumulator_so_c_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_dl_data_accumulator_so_c_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_dl_data_accumulator_so_c_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_bms_dl_data_accumulator_temp_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_bms_dl_data_accumulator_temp_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_bms_dl_data_accumulator_temp_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_pel_pdo_1_rx_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_pel_pdo_1_rx_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->enable_drive_left, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_set_point_left, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_set_point_left, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_limit_left, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_limit_left, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->error_reset_left, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->error_reset_left, 8u, 0xffu);

    return (7);
}

int lynx19gw_nr_pel_pdo_1_rx_unpack(
    struct lynx19gw_nr_pel_pdo_1_rx_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->enable_drive_left |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_set_point_left |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_set_point_left |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_limit_left |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_limit_left |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->error_reset_left |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->error_reset_left |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_nr_pel_pdo_1_rx_enable_drive_left_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_pel_pdo_1_rx_enable_drive_left_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_1_rx_enable_drive_left_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_pel_pdo_1_rx_torque_set_point_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_pel_pdo_1_rx_torque_set_point_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_1_rx_torque_set_point_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_pel_pdo_1_rx_speed_limit_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_pel_pdo_1_rx_speed_limit_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_1_rx_speed_limit_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_pel_pdo_1_rx_error_reset_left_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_pel_pdo_1_rx_error_reset_left_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_pel_pdo_1_rx_error_reset_left_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_sensors_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_3_t *src_p,
    size_t size)
{
    uint16_t acceleration_x;
    uint16_t acceleration_y;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    acceleration_x = (uint16_t)src_p->acceleration_x;
    dst_p[0] |= pack_left_shift_u16(acceleration_x, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(acceleration_x, 8u, 0xffu);
    acceleration_y = (uint16_t)src_p->acceleration_y;
    dst_p[2] |= pack_left_shift_u16(acceleration_y, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(acceleration_y, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->water_temp_1, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->water_temp_2, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->water_temp_3, 0u, 0xffu);
    dst_p[7] |= pack_left_shift_u8(src_p->brake_rear, 0u, 0xffu);

    return (8);
}

int lynx19gw_nr_dl_sensors_3_unpack(
    struct lynx19gw_nr_dl_sensors_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t acceleration_x;
    uint16_t acceleration_y;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    acceleration_x = 0u;
    acceleration_x |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    acceleration_x |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->acceleration_x = (int16_t)acceleration_x;
    acceleration_y = 0u;
    acceleration_y |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    acceleration_y |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->acceleration_y = (int16_t)acceleration_y;
    dst_p->water_temp_1 |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->water_temp_2 |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->water_temp_3 |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);
    dst_p->brake_rear |= unpack_right_shift_u8(src_p[7], 0u, 0xffu);

    return (0);
}

int16_t lynx19gw_nr_dl_sensors_3_acceleration_x_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double lynx19gw_nr_dl_sensors_3_acceleration_x_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool lynx19gw_nr_dl_sensors_3_acceleration_x_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int16_t lynx19gw_nr_dl_sensors_3_acceleration_y_encode(double value)
{
    return (int16_t)(value / 0.01);
}

double lynx19gw_nr_dl_sensors_3_acceleration_y_decode(int16_t value)
{
    return ((double)value * 0.01);
}

bool lynx19gw_nr_dl_sensors_3_acceleration_y_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nr_dl_sensors_3_water_temp_1_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_3_water_temp_1_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_3_water_temp_1_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

uint8_t lynx19gw_nr_dl_sensors_3_water_temp_2_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_3_water_temp_2_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_3_water_temp_2_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

uint8_t lynx19gw_nr_dl_sensors_3_water_temp_3_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_3_water_temp_3_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_3_water_temp_3_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

uint8_t lynx19gw_nr_dl_sensors_3_brake_rear_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_3_brake_rear_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_3_brake_rear_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_sensors_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_2_t *src_p,
    size_t size)
{
    uint16_t yaw;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u8(src_p->rotor_ambient_temp_l, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->rotor_ambient_temp_r, 0u, 0xffu);
    dst_p[2] |= pack_left_shift_u8(src_p->rotor_object_temp_l, 0u, 0xffu);
    dst_p[3] |= pack_left_shift_u8(src_p->rotor_object_temp_r, 0u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->gear_box_temp_l, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->gear_box_temp_r, 0u, 0xffu);
    yaw = (uint16_t)src_p->yaw;
    dst_p[6] |= pack_left_shift_u16(yaw, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(yaw, 8u, 0xffu);

    return (8);
}

int lynx19gw_nr_dl_sensors_2_unpack(
    struct lynx19gw_nr_dl_sensors_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint16_t yaw;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->rotor_ambient_temp_l |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->rotor_ambient_temp_r |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->rotor_object_temp_l |= unpack_right_shift_u8(src_p[2], 0u, 0xffu);
    dst_p->rotor_object_temp_r |= unpack_right_shift_u8(src_p[3], 0u, 0xffu);
    dst_p->gear_box_temp_l |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->gear_box_temp_r |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    yaw = 0u;
    yaw |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    yaw |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);
    dst_p->yaw = (int16_t)yaw;

    return (0);
}

uint8_t lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_l_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_l_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_r_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_r_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_rotor_ambient_temp_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nr_dl_sensors_2_rotor_object_temp_l_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_2_rotor_object_temp_l_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_rotor_object_temp_l_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nr_dl_sensors_2_rotor_object_temp_r_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_2_rotor_object_temp_r_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_rotor_object_temp_r_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_nr_dl_sensors_2_gear_box_temp_l_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_2_gear_box_temp_l_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_gear_box_temp_l_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

uint8_t lynx19gw_nr_dl_sensors_2_gear_box_temp_r_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nr_dl_sensors_2_gear_box_temp_r_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_gear_box_temp_r_is_in_range(uint8_t value)
{
    return (value <= 200u);
}

int16_t lynx19gw_nr_dl_sensors_2_yaw_encode(double value)
{
    return (int16_t)(value);
}

double lynx19gw_nr_dl_sensors_2_yaw_decode(int16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_2_yaw_is_in_range(int16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nr_dl_sensors_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nr_dl_sensors_1_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->damper_rl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->damper_rl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->damper_rr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->damper_rr, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->wheel_speed_rl, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->wheel_speed_rl, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->wheel_speed_rr, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->wheel_speed_rr, 8u, 0xffu);

    return (8);
}

int lynx19gw_nr_dl_sensors_1_unpack(
    struct lynx19gw_nr_dl_sensors_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->damper_rl |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->damper_rl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->damper_rr |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->damper_rr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->wheel_speed_rl |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->wheel_speed_rl |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->wheel_speed_rr |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->wheel_speed_rr |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_nr_dl_sensors_1_damper_rl_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_dl_sensors_1_damper_rl_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_1_damper_rl_is_in_range(uint16_t value)
{
    return (value <= 6000u);
}

uint16_t lynx19gw_nr_dl_sensors_1_damper_rr_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nr_dl_sensors_1_damper_rr_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nr_dl_sensors_1_damper_rr_is_in_range(uint16_t value)
{
    return (value <= 6000u);
}

uint16_t lynx19gw_nr_dl_sensors_1_wheel_speed_rl_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double lynx19gw_nr_dl_sensors_1_wheel_speed_rl_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool lynx19gw_nr_dl_sensors_1_wheel_speed_rl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nr_dl_sensors_1_wheel_speed_rr_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double lynx19gw_nr_dl_sensors_1_wheel_speed_rr_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool lynx19gw_nr_dl_sensors_1_wheel_speed_rr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_nf_nr_sensors_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_nr_sensors_1_t *src_p,
    size_t size)
{
    uint8_t steering_angle;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u16(src_p->disk_temp_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->disk_temp_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->disk_temp_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->disk_temp_fr, 8u, 0xffu);
    steering_angle = (uint8_t)src_p->steering_angle;
    dst_p[4] |= pack_left_shift_u8(steering_angle, 0u, 0xffu);
    dst_p[5] |= pack_left_shift_u8(src_p->brake, 0u, 0xffu);
    dst_p[6] |= pack_left_shift_u8(src_p->throttle, 0u, 0xffu);

    return (7);
}

int lynx19gw_nf_nr_sensors_1_unpack(
    struct lynx19gw_nf_nr_sensors_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t steering_angle;

    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->disk_temp_fl |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->disk_temp_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->disk_temp_fr |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->disk_temp_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    steering_angle = 0u;
    steering_angle |= unpack_right_shift_u8(src_p[4], 0u, 0xffu);
    dst_p->steering_angle = (int8_t)steering_angle;
    dst_p->brake |= unpack_right_shift_u8(src_p[5], 0u, 0xffu);
    dst_p->throttle |= unpack_right_shift_u8(src_p[6], 0u, 0xffu);

    return (0);
}

uint16_t lynx19gw_nf_nr_sensors_1_disk_temp_fl_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nf_nr_sensors_1_disk_temp_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_1_disk_temp_fl_is_in_range(uint16_t value)
{
    return (value <= 255u);
}

uint16_t lynx19gw_nf_nr_sensors_1_disk_temp_fr_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nf_nr_sensors_1_disk_temp_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_1_disk_temp_fr_is_in_range(uint16_t value)
{
    return (value <= 255u);
}

int8_t lynx19gw_nf_nr_sensors_1_steering_angle_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_nf_nr_sensors_1_steering_angle_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_1_steering_angle_is_in_range(int8_t value)
{
    return ((value >= -120) && (value <= 120));
}

uint8_t lynx19gw_nf_nr_sensors_1_brake_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nf_nr_sensors_1_brake_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_1_brake_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

uint8_t lynx19gw_nf_nr_sensors_1_throttle_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_nf_nr_sensors_1_throttle_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_1_throttle_is_in_range(uint8_t value)
{
    return (value <= 100u);
}

int lynx19gw_nf_nr_sensors_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_nf_nr_sensors_2_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    dst_p[0] |= pack_left_shift_u16(src_p->wheel_speed_fl, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u16(src_p->wheel_speed_fl, 8u, 0xffu);
    dst_p[2] |= pack_left_shift_u16(src_p->wheel_speed_fr, 0u, 0xffu);
    dst_p[3] |= pack_right_shift_u16(src_p->wheel_speed_fr, 8u, 0xffu);
    dst_p[4] |= pack_left_shift_u16(src_p->damper_fl, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u16(src_p->damper_fl, 8u, 0xffu);
    dst_p[6] |= pack_left_shift_u16(src_p->damper_fr, 0u, 0xffu);
    dst_p[7] |= pack_right_shift_u16(src_p->damper_fr, 8u, 0xffu);

    return (8);
}

int lynx19gw_nf_nr_sensors_2_unpack(
    struct lynx19gw_nf_nr_sensors_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->wheel_speed_fl |= unpack_right_shift_u16(src_p[0], 0u, 0xffu);
    dst_p->wheel_speed_fl |= unpack_left_shift_u16(src_p[1], 8u, 0xffu);
    dst_p->wheel_speed_fr |= unpack_right_shift_u16(src_p[2], 0u, 0xffu);
    dst_p->wheel_speed_fr |= unpack_left_shift_u16(src_p[3], 8u, 0xffu);
    dst_p->damper_fl |= unpack_right_shift_u16(src_p[4], 0u, 0xffu);
    dst_p->damper_fl |= unpack_left_shift_u16(src_p[5], 8u, 0xffu);
    dst_p->damper_fr |= unpack_right_shift_u16(src_p[6], 0u, 0xffu);
    dst_p->damper_fr |= unpack_left_shift_u16(src_p[7], 8u, 0xffu);

    return (0);
}

uint16_t lynx19gw_nf_nr_sensors_2_wheel_speed_fl_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double lynx19gw_nf_nr_sensors_2_wheel_speed_fl_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool lynx19gw_nf_nr_sensors_2_wheel_speed_fl_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nf_nr_sensors_2_wheel_speed_fr_encode(double value)
{
    return (uint16_t)(value / 0.1);
}

double lynx19gw_nf_nr_sensors_2_wheel_speed_fr_decode(uint16_t value)
{
    return ((double)value * 0.1);
}

bool lynx19gw_nf_nr_sensors_2_wheel_speed_fr_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_nf_nr_sensors_2_damper_fl_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nf_nr_sensors_2_damper_fl_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_2_damper_fl_is_in_range(uint16_t value)
{
    return (value <= 6000u);
}

uint16_t lynx19gw_nf_nr_sensors_2_damper_fr_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_nf_nr_sensors_2_damper_fr_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_nf_nr_sensors_2_damper_fr_is_in_range(uint16_t value)
{
    return (value <= 6000u);
}

/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANREADING_ASSTATUS_HPP
#define OPENDLV_PROXYCANREADING_ASSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API AsStatus {
    private:
        static constexpr const char* TheShortName = "AsStatus";
        static constexpr const char* TheLongName = "opendlv.proxyCANReading.AsStatus";

    public:
        inline static int32_t ID() {
            return 2001;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        AsStatus() = default;
        AsStatus(const AsStatus&) = default;
        AsStatus& operator=(const AsStatus&) = default;
        AsStatus(AsStatus&&) = default;
        AsStatus& operator=(AsStatus&&) = default;
        ~AsStatus() = default;

    public:
        
        inline AsStatus& accSoC(const int &v) noexcept {
            m_accSoC = v;
            return *this;
        }
        inline int accSoC() const noexcept {
            return m_accSoC;
        }
        
        inline AsStatus& brakeRear(const int &v) noexcept {
            m_brakeRear = v;
            return *this;
        }
        inline int brakeRear() const noexcept {
            return m_brakeRear;
        }
        
        inline AsStatus& brakeFront(const int &v) noexcept {
            m_brakeFront = v;
            return *this;
        }
        inline int brakeFront() const noexcept {
            return m_brakeFront;
        }
        
        inline AsStatus& dlStatus(const int &v) noexcept {
            m_dlStatus = v;
            return *this;
        }
        inline int dlStatus() const noexcept {
            return m_dlStatus;
        }
        
        inline AsStatus& asMission(const int &v) noexcept {
            m_asMission = v;
            return *this;
        }
        inline int asMission() const noexcept {
            return m_asMission;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("accSoC"s), m_accSoC, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("brakeRear"s), m_brakeRear, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("brakeFront"s), m_brakeFront, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("int"s), std::move("dlStatus"s), m_dlStatus, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("int"s), std::move("asMission"s), m_asMission, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("accSoC"s), m_accSoC, visitor);
            
            doVisit(2, std::move("int"s), std::move("brakeRear"s), m_brakeRear, visitor);
            
            doVisit(3, std::move("int"s), std::move("brakeFront"s), m_brakeFront, visitor);
            
            doVisit(4, std::move("int"s), std::move("dlStatus"s), m_dlStatus, visitor);
            
            doVisit(5, std::move("int"s), std::move("asMission"s), m_asMission, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("accSoC"s), m_accSoC, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("brakeRear"s), m_brakeRear, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("brakeFront"s), m_brakeFront, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("int"s), std::move("dlStatus"s), m_dlStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("int"s), std::move("asMission"s), m_asMission, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_accSoC{  }; // field identifier = 1.
        
        int m_brakeRear{  }; // field identifier = 2.
        
        int m_brakeFront{  }; // field identifier = 3.
        
        int m_dlStatus{  }; // field identifier = 4.
        
        int m_asMission{  }; // field identifier = 5.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANReading::AsStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANReading::AsStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANREADING_WHEELSPEEDFRONT_HPP
#define OPENDLV_PROXYCANREADING_WHEELSPEEDFRONT_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API WheelSpeedFront {
    private:
        static constexpr const char* TheShortName = "WheelSpeedFront";
        static constexpr const char* TheLongName = "opendlv.proxyCANReading.WheelSpeedFront";

    public:
        inline static int32_t ID() {
            return 2002;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        WheelSpeedFront() = default;
        WheelSpeedFront(const WheelSpeedFront&) = default;
        WheelSpeedFront& operator=(const WheelSpeedFront&) = default;
        WheelSpeedFront(WheelSpeedFront&&) = default;
        WheelSpeedFront& operator=(WheelSpeedFront&&) = default;
        ~WheelSpeedFront() = default;

    public:
        
        inline WheelSpeedFront& wheelFrontRight(const float &v) noexcept {
            m_wheelFrontRight = v;
            return *this;
        }
        inline float wheelFrontRight() const noexcept {
            return m_wheelFrontRight;
        }
        
        inline WheelSpeedFront& wheelFrontLeft(const float &v) noexcept {
            m_wheelFrontLeft = v;
            return *this;
        }
        inline float wheelFrontLeft() const noexcept {
            return m_wheelFrontLeft;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, visitor);
            
            doVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_wheelFrontRight{ 0.0f }; // field identifier = 1.
        
        float m_wheelFrontLeft{ 0.0f }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANReading::WheelSpeedFront> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANReading::WheelSpeedFront> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANREADING_WHEELSPEEDRARE_HPP
#define OPENDLV_PROXYCANREADING_WHEELSPEEDRARE_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API WheelSpeedRare {
    private:
        static constexpr const char* TheShortName = "WheelSpeedRare";
        static constexpr const char* TheLongName = "opendlv.proxyCANReading.WheelSpeedRare";

    public:
        inline static int32_t ID() {
            return 2003;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        WheelSpeedRare() = default;
        WheelSpeedRare(const WheelSpeedRare&) = default;
        WheelSpeedRare& operator=(const WheelSpeedRare&) = default;
        WheelSpeedRare(WheelSpeedRare&&) = default;
        WheelSpeedRare& operator=(WheelSpeedRare&&) = default;
        ~WheelSpeedRare() = default;

    public:
        
        inline WheelSpeedRare& wheelRareRight(const float &v) noexcept {
            m_wheelRareRight = v;
            return *this;
        }
        inline float wheelRareRight() const noexcept {
            return m_wheelRareRight;
        }
        
        inline WheelSpeedRare& wheelRareLeft(const float &v) noexcept {
            m_wheelRareLeft = v;
            return *this;
        }
        inline float wheelRareLeft() const noexcept {
            return m_wheelRareLeft;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("wheelRareRight"s), m_wheelRareRight, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("wheelRareLeft"s), m_wheelRareLeft, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("wheelRareRight"s), m_wheelRareRight, visitor);
            
            doVisit(2, std::move("float"s), std::move("wheelRareLeft"s), m_wheelRareLeft, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("wheelRareRight"s), m_wheelRareRight, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("wheelRareLeft"s), m_wheelRareLeft, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_wheelRareRight{ 0.0f }; // field identifier = 1.
        
        float m_wheelRareLeft{ 0.0f }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANReading::WheelSpeedRare> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANReading::WheelSpeedRare> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANREADING_PEDALRATIO_HPP
#define OPENDLV_PROXYCANREADING_PEDALRATIO_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API PedalRatio {
    private:
        static constexpr const char* TheShortName = "PedalRatio";
        static constexpr const char* TheLongName = "opendlv.proxyCANReading.PedalRatio";

    public:
        inline static int32_t ID() {
            return 2004;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        PedalRatio() = default;
        PedalRatio(const PedalRatio&) = default;
        PedalRatio& operator=(const PedalRatio&) = default;
        PedalRatio(PedalRatio&&) = default;
        PedalRatio& operator=(PedalRatio&&) = default;
        ~PedalRatio() = default;

    public:
        
        inline PedalRatio& throttle(const int &v) noexcept {
            m_throttle = v;
            return *this;
        }
        inline int throttle() const noexcept {
            return m_throttle;
        }
        
        inline PedalRatio& brake(const int &v) noexcept {
            m_brake = v;
            return *this;
        }
        inline int brake() const noexcept {
            return m_brake;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("throttle"s), m_throttle, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("brake"s), m_brake, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("throttle"s), m_throttle, visitor);
            
            doVisit(2, std::move("int"s), std::move("brake"s), m_brake, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("throttle"s), m_throttle, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("brake"s), m_brake, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_throttle{  }; // field identifier = 1.
        
        int m_brake{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANReading::PedalRatio> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANReading::PedalRatio> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANWRITING_ASTORQUE_HPP
#define OPENDLV_PROXYCANWRITING_ASTORQUE_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API ASTorque {
    private:
        static constexpr const char* TheShortName = "ASTorque";
        static constexpr const char* TheLongName = "opendlv.proxyCANWriting.ASTorque";

    public:
        inline static int32_t ID() {
            return 2005;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        ASTorque() = default;
        ASTorque(const ASTorque&) = default;
        ASTorque& operator=(const ASTorque&) = default;
        ASTorque(ASTorque&&) = default;
        ASTorque& operator=(ASTorque&&) = default;
        ~ASTorque() = default;

    public:
        
        inline ASTorque& torqueLeft(const int &v) noexcept {
            m_torqueLeft = v;
            return *this;
        }
        inline int torqueLeft() const noexcept {
            return m_torqueLeft;
        }
        
        inline ASTorque& torqueRight(const int &v) noexcept {
            m_torqueRight = v;
            return *this;
        }
        inline int torqueRight() const noexcept {
            return m_torqueRight;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("torqueLeft"s), m_torqueLeft, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("torqueRight"s), m_torqueRight, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("torqueLeft"s), m_torqueLeft, visitor);
            
            doVisit(2, std::move("int"s), std::move("torqueRight"s), m_torqueRight, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("torqueLeft"s), m_torqueLeft, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("torqueRight"s), m_torqueRight, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_torqueLeft{  }; // field identifier = 1.
        
        int m_torqueRight{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANWriting::ASTorque> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANWriting::ASTorque> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANWRITING_ASSTATUS_HPP
#define OPENDLV_PROXYCANWRITING_ASSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API ASStatus {
    private:
        static constexpr const char* TheShortName = "ASStatus";
        static constexpr const char* TheLongName = "opendlv.proxyCANWriting.ASStatus";

    public:
        inline static int32_t ID() {
            return 2006;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        ASStatus() = default;
        ASStatus(const ASStatus&) = default;
        ASStatus& operator=(const ASStatus&) = default;
        ASStatus(ASStatus&&) = default;
        ASStatus& operator=(ASStatus&&) = default;
        ~ASStatus() = default;

    public:
        
        inline ASStatus& asRedyToDrive(const int &v) noexcept {
            m_asRedyToDrive = v;
            return *this;
        }
        inline int asRedyToDrive() const noexcept {
            return m_asRedyToDrive;
        }
        
        inline ASStatus& steeringPosition(const int &v) noexcept {
            m_steeringPosition = v;
            return *this;
        }
        inline int steeringPosition() const noexcept {
            return m_steeringPosition;
        }
        
        inline ASStatus& rackPosition(const int &v) noexcept {
            m_rackPosition = v;
            return *this;
        }
        inline int rackPosition() const noexcept {
            return m_rackPosition;
        }
        
        inline ASStatus& pressureService(const int &v) noexcept {
            m_pressureService = v;
            return *this;
        }
        inline int pressureService() const noexcept {
            return m_pressureService;
        }
        
        inline ASStatus& pressureRegulator(const int &v) noexcept {
            m_pressureRegulator = v;
            return *this;
        }
        inline int pressureRegulator() const noexcept {
            return m_pressureRegulator;
        }
        
        inline ASStatus& pressureEBSLine(const int &v) noexcept {
            m_pressureEBSLine = v;
            return *this;
        }
        inline int pressureEBSLine() const noexcept {
            return m_pressureEBSLine;
        }
        
        inline ASStatus& pressureEBSAct(const int &v) noexcept {
            m_pressureEBSAct = v;
            return *this;
        }
        inline int pressureEBSAct() const noexcept {
            return m_pressureEBSAct;
        }
        
        inline ASStatus& asState(const int &v) noexcept {
            m_asState = v;
            return *this;
        }
        inline int asState() const noexcept {
            return m_asState;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("asRedyToDrive"s), m_asRedyToDrive, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("steeringPosition"s), m_steeringPosition, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("rackPosition"s), m_rackPosition, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("int"s), std::move("pressureService"s), m_pressureService, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("int"s), std::move("pressureRegulator"s), m_pressureRegulator, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("int"s), std::move("pressureEBSLine"s), m_pressureEBSLine, visitor);
                return;
            }
            
            if (7 == fieldId) {
                doVisit(7, std::move("int"s), std::move("pressureEBSAct"s), m_pressureEBSAct, visitor);
                return;
            }
            
            if (8 == fieldId) {
                doVisit(8, std::move("int"s), std::move("asState"s), m_asState, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("asRedyToDrive"s), m_asRedyToDrive, visitor);
            
            doVisit(2, std::move("int"s), std::move("steeringPosition"s), m_steeringPosition, visitor);
            
            doVisit(3, std::move("int"s), std::move("rackPosition"s), m_rackPosition, visitor);
            
            doVisit(4, std::move("int"s), std::move("pressureService"s), m_pressureService, visitor);
            
            doVisit(5, std::move("int"s), std::move("pressureRegulator"s), m_pressureRegulator, visitor);
            
            doVisit(6, std::move("int"s), std::move("pressureEBSLine"s), m_pressureEBSLine, visitor);
            
            doVisit(7, std::move("int"s), std::move("pressureEBSAct"s), m_pressureEBSAct, visitor);
            
            doVisit(8, std::move("int"s), std::move("asState"s), m_asState, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("asRedyToDrive"s), m_asRedyToDrive, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("steeringPosition"s), m_steeringPosition, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("rackPosition"s), m_rackPosition, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("int"s), std::move("pressureService"s), m_pressureService, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("int"s), std::move("pressureRegulator"s), m_pressureRegulator, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("int"s), std::move("pressureEBSLine"s), m_pressureEBSLine, preVisit, visit, postVisit);
            
            doTripletForwardVisit(7, std::move("int"s), std::move("pressureEBSAct"s), m_pressureEBSAct, preVisit, visit, postVisit);
            
            doTripletForwardVisit(8, std::move("int"s), std::move("asState"s), m_asState, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_asRedyToDrive{  }; // field identifier = 1.
        
        int m_steeringPosition{  }; // field identifier = 2.
        
        int m_rackPosition{  }; // field identifier = 3.
        
        int m_pressureService{  }; // field identifier = 4.
        
        int m_pressureRegulator{  }; // field identifier = 5.
        
        int m_pressureEBSLine{  }; // field identifier = 6.
        
        int m_pressureEBSAct{  }; // field identifier = 7.
        
        int m_asState{  }; // field identifier = 8.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANWriting::ASStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANWriting::ASStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANWRITING_NMT_HPP
#define OPENDLV_PROXYCANWRITING_NMT_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API NMT {
    private:
        static constexpr const char* TheShortName = "NMT";
        static constexpr const char* TheLongName = "opendlv.proxyCANWriting.NMT";

    public:
        inline static int32_t ID() {
            return 2007;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        NMT() = default;
        NMT(const NMT&) = default;
        NMT& operator=(const NMT&) = default;
        NMT(NMT&&) = default;
        NMT& operator=(NMT&&) = default;
        ~NMT() = default;

    public:
        
        inline NMT& nodeState(const uint8_t &v) noexcept {
            m_nodeState = v;
            return *this;
        }
        inline uint8_t nodeState() const noexcept {
            return m_nodeState;
        }
        
        inline NMT& nodeId(const uint8_t &v) noexcept {
            m_nodeId = v;
            return *this;
        }
        inline uint8_t nodeId() const noexcept {
            return m_nodeId;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("uint8_t"s), std::move("nodeState"s), m_nodeState, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("uint8_t"s), std::move("nodeId"s), m_nodeId, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("uint8_t"s), std::move("nodeState"s), m_nodeState, visitor);
            
            doVisit(2, std::move("uint8_t"s), std::move("nodeId"s), m_nodeId, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("uint8_t"s), std::move("nodeState"s), m_nodeState, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("uint8_t"s), std::move("nodeId"s), m_nodeId, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        uint8_t m_nodeState{ 0 }; // field identifier = 1.
        
        uint8_t m_nodeId{ 0 }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANWriting::NMT> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANWriting::NMT> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_PROXYCANREADING_RESSTATUS_HPP
#define OPENDLV_PROXYCANREADING_RESSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace proxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API RESStatus {
    private:
        static constexpr const char* TheShortName = "RESStatus";
        static constexpr const char* TheLongName = "opendlv.proxyCANReading.RESStatus";

    public:
        inline static int32_t ID() {
            return 2008;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        RESStatus() = default;
        RESStatus(const RESStatus&) = default;
        RESStatus& operator=(const RESStatus&) = default;
        RESStatus(RESStatus&&) = default;
        RESStatus& operator=(RESStatus&&) = default;
        ~RESStatus() = default;

    public:
        
        inline RESStatus& resStatus(const int &v) noexcept {
            m_resStatus = v;
            return *this;
        }
        inline int resStatus() const noexcept {
            return m_resStatus;
        }
        
        inline RESStatus& resEStop(const int &v) noexcept {
            m_resEStop = v;
            return *this;
        }
        inline int resEStop() const noexcept {
            return m_resEStop;
        }
        
        inline RESStatus& resQuality(const int &v) noexcept {
            m_resQuality = v;
            return *this;
        }
        inline int resQuality() const noexcept {
            return m_resQuality;
        }
        
        inline RESStatus& resButtons(const int &v) noexcept {
            m_resButtons = v;
            return *this;
        }
        inline int resButtons() const noexcept {
            return m_resButtons;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("resStatus"s), m_resStatus, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("resEStop"s), m_resEStop, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("resQuality"s), m_resQuality, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("int"s), std::move("resButtons"s), m_resButtons, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("resStatus"s), m_resStatus, visitor);
            
            doVisit(2, std::move("int"s), std::move("resEStop"s), m_resEStop, visitor);
            
            doVisit(3, std::move("int"s), std::move("resQuality"s), m_resQuality, visitor);
            
            doVisit(4, std::move("int"s), std::move("resButtons"s), m_resButtons, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("resStatus"s), m_resStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("resEStop"s), m_resEStop, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("resQuality"s), m_resQuality, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("int"s), std::move("resButtons"s), m_resButtons, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_resStatus{  }; // field identifier = 1.
        
        int m_resEStop{  }; // field identifier = 2.
        
        int m_resQuality{  }; // field identifier = 3.
        
        int m_resButtons{  }; // field identifier = 4.
        
};
}}

template<>
struct isVisitable<opendlv::proxyCANReading::RESStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::proxyCANReading::RESStatus> {
    static const bool value = true;
};
#endif

