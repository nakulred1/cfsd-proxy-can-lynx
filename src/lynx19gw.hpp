/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Wed Jul 22 10:47:29 2020.
 */

#ifndef LYNX19GW_H
#define LYNX19GW_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

#define LYNX19GW_MOTOR_CONTROL_MESSAGE_FRAME_ID (0x10u)
#define LYNX19GW_FRONT_NODE_STATUS_FRAME_ID (0x1fu)
#define LYNX19GW_REAR_NODE_STATUS_FRAME_ID (0x20u)
#define LYNX19GW_AMS_STATUS_FRAME_ID (0x21u)
#define LYNX19GW_APPS_FRAME_ID (0x32u)
#define LYNX19GW_TEST_CAN_MESSAGE_1_FRAME_ID (0xc8u)
#define LYNX19GW_TEST_CAN_MESSAGE_2_FRAME_ID (0xc9u)
#define LYNX19GW_TEST_CAN_MESSAGE_3_FRAME_ID (0xcau)

/**
 * Signals in message MOTOR_CONTROL_MESSAGE.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_motor_control_message_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_enabled;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t max_power_setpoint;
};

/**
 * Signals in message FRONT_NODE_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_front_node_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message REAR_NODE_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_rear_node_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message AMS_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_ams_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message APPS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_apps_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float throttle_percentage;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t apps_fault;
};

/**
 * Signals in message TEST_CAN_MESSAGE_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_test_can_message_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_message;
};

/**
 * Signals in message TEST_CAN_MESSAGE_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_test_can_message_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_message;
};

/**
 * Signals in message TEST_CAN_MESSAGE_3.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_test_can_message_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_message;
};

/**
 * Pack message MOTOR_CONTROL_MESSAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_motor_control_message_pack(
    uint8_t *dst_p,
    const struct lynx19gw_motor_control_message_t *src_p,
    size_t size);

/**
 * Unpack message MOTOR_CONTROL_MESSAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_motor_control_message_unpack(
    struct lynx19gw_motor_control_message_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_motor_control_message_pwm_enabled_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_pwm_enabled_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_pwm_enabled_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_motor_control_message_torque_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_torque_setpoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_torque_setpoint_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_motor_control_message_speed_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_speed_setpoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_speed_setpoint_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_motor_control_message_max_power_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_max_power_setpoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_max_power_setpoint_is_in_range(uint16_t value);

/**
 * Pack message FRONT_NODE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_front_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_front_node_status_t *src_p,
    size_t size);

/**
 * Unpack message FRONT_NODE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_front_node_status_unpack(
    struct lynx19gw_front_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_front_node_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_front_node_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_front_node_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_front_node_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_front_node_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_front_node_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message REAR_NODE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_rear_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_rear_node_status_t *src_p,
    size_t size);

/**
 * Unpack message REAR_NODE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_rear_node_status_unpack(
    struct lynx19gw_rear_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_rear_node_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_rear_node_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_rear_node_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_rear_node_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_rear_node_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_rear_node_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message AMS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_ams_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_ams_status_t *src_p,
    size_t size);

/**
 * Unpack message AMS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_ams_status_unpack(
    struct lynx19gw_ams_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_ams_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ams_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ams_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_ams_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ams_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ams_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message APPS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_apps_pack(
    uint8_t *dst_p,
    const struct lynx19gw_apps_t *src_p,
    size_t size);

/**
 * Unpack message APPS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_apps_unpack(
    struct lynx19gw_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_apps_throttle_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_apps_throttle_percentage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_apps_throttle_percentage_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_apps_apps_fault_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_apps_apps_fault_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_apps_apps_fault_is_in_range(uint8_t value);

/**
 * Pack message TEST_CAN_MESSAGE_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_test_can_message_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_1_t *src_p,
    size_t size);

/**
 * Unpack message TEST_CAN_MESSAGE_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_test_can_message_1_unpack(
    struct lynx19gw_test_can_message_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_test_can_message_1_test_message_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_test_can_message_1_test_message_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_test_can_message_1_test_message_is_in_range(uint8_t value);

/**
 * Pack message TEST_CAN_MESSAGE_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_test_can_message_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_2_t *src_p,
    size_t size);

/**
 * Unpack message TEST_CAN_MESSAGE_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_test_can_message_2_unpack(
    struct lynx19gw_test_can_message_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_test_can_message_2_test_message_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_test_can_message_2_test_message_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_test_can_message_2_test_message_is_in_range(uint8_t value);

/**
 * Pack message TEST_CAN_MESSAGE_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_test_can_message_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_3_t *src_p,
    size_t size);

/**
 * Unpack message TEST_CAN_MESSAGE_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_test_can_message_3_unpack(
    struct lynx19gw_test_can_message_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_test_can_message_3_test_message_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_test_can_message_3_test_message_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_test_can_message_3_test_message_is_in_range(uint8_t value);

#endif
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Wed Jul 22 10:47:29 2020.
 */

#include <string.h>

//#include "lynx19gw.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int lynx19gw_motor_control_message_pack(
    uint8_t *dst_p,
    const struct lynx19gw_motor_control_message_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->pwm_enabled, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_setpoint, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_setpoint, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_setpoint, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_setpoint, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->max_power_setpoint, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->max_power_setpoint, 8u, 0xffu);

    return (7);
}

int lynx19gw_motor_control_message_unpack(
    struct lynx19gw_motor_control_message_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->pwm_enabled |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_setpoint |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_setpoint |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_setpoint |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_setpoint |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->max_power_setpoint |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->max_power_setpoint |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_motor_control_message_pwm_enabled_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_motor_control_message_pwm_enabled_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_pwm_enabled_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_motor_control_message_torque_setpoint_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_motor_control_message_torque_setpoint_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_torque_setpoint_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_motor_control_message_speed_setpoint_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_motor_control_message_speed_setpoint_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_speed_setpoint_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_motor_control_message_max_power_setpoint_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_motor_control_message_max_power_setpoint_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_max_power_setpoint_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_front_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_front_node_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_front_node_status_unpack(
    struct lynx19gw_front_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_front_node_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_front_node_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_front_node_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_front_node_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_front_node_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_front_node_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_rear_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_rear_node_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_rear_node_status_unpack(
    struct lynx19gw_rear_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_rear_node_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_rear_node_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_rear_node_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_rear_node_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_rear_node_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_rear_node_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_ams_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_ams_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_ams_status_unpack(
    struct lynx19gw_ams_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_ams_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_ams_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_ams_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_ams_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_ams_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_ams_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_apps_pack(
    uint8_t *dst_p,
    const struct lynx19gw_apps_t *src_p,
    size_t size)
{
    uint32_t throttle_percentage;

    if (size < 5u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 5);

    memcpy(&throttle_percentage, &src_p->throttle_percentage, sizeof(throttle_percentage));
    dst_p[0] |= pack_left_shift_u32(throttle_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_percentage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_percentage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_percentage, 24u, 0xffu);
    dst_p[4] |= pack_left_shift_u8(src_p->apps_fault, 0u, 0x01u);

    return (5);
}

int lynx19gw_apps_unpack(
    struct lynx19gw_apps_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_percentage;

    if (size < 5u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    throttle_percentage = 0u;
    throttle_percentage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_percentage, &throttle_percentage, sizeof(dst_p->throttle_percentage));
    dst_p->apps_fault |= unpack_right_shift_u8(src_p[4], 0u, 0x01u);

    return (0);
}

float lynx19gw_apps_throttle_percentage_encode(double value)
{
    return (float)(value);
}

double lynx19gw_apps_throttle_percentage_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_apps_throttle_percentage_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

uint8_t lynx19gw_apps_apps_fault_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_apps_apps_fault_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_apps_apps_fault_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int lynx19gw_test_can_message_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_1_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->test_message, 0u, 0xffu);

    return (1);
}

int lynx19gw_test_can_message_1_unpack(
    struct lynx19gw_test_can_message_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->test_message |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_test_can_message_1_test_message_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_test_can_message_1_test_message_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_test_can_message_1_test_message_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_test_can_message_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_2_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->test_message, 0u, 0xffu);

    return (1);
}

int lynx19gw_test_can_message_2_unpack(
    struct lynx19gw_test_can_message_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->test_message |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_test_can_message_2_test_message_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_test_can_message_2_test_message_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_test_can_message_2_test_message_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_test_can_message_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_3_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->test_message, 0u, 0xffu);

    return (1);
}

int lynx19gw_test_can_message_3_unpack(
    struct lynx19gw_test_can_message_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->test_message |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_test_can_message_3_test_message_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_test_can_message_3_test_message_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_test_can_message_3_test_message_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_TEST_HPP
#define OPENDLV_CFSDPROXYCANREADING_TEST_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API Test {
    private:
        static constexpr const char* TheShortName = "Test";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.Test";

    public:
        inline static int32_t ID() {
            return 1001;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Test() = default;
        Test(const Test&) = default;
        Test& operator=(const Test&) = default;
        Test(Test&&) = default;
        Test& operator=(Test&&) = default;
        ~Test() = default;

    public:
        
        inline Test& testCanMessage1(const int &v) noexcept {
            m_testCanMessage1 = v;
            return *this;
        }
        inline int testCanMessage1() const noexcept {
            return m_testCanMessage1;
        }
        
        inline Test& testCanMessage2(const int &v) noexcept {
            m_testCanMessage2 = v;
            return *this;
        }
        inline int testCanMessage2() const noexcept {
            return m_testCanMessage2;
        }
        
        inline Test& testCanMessage3(const int &v) noexcept {
            m_testCanMessage3 = v;
            return *this;
        }
        inline int testCanMessage3() const noexcept {
            return m_testCanMessage3;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("testCanMessage1"s), m_testCanMessage1, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("testCanMessage2"s), m_testCanMessage2, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("testCanMessage3"s), m_testCanMessage3, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("testCanMessage1"s), m_testCanMessage1, visitor);
            
            doVisit(2, std::move("int"s), std::move("testCanMessage2"s), m_testCanMessage2, visitor);
            
            doVisit(3, std::move("int"s), std::move("testCanMessage3"s), m_testCanMessage3, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("testCanMessage1"s), m_testCanMessage1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("testCanMessage2"s), m_testCanMessage2, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("testCanMessage3"s), m_testCanMessage3, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_testCanMessage1{  }; // field identifier = 1.
        
        int m_testCanMessage2{  }; // field identifier = 2.
        
        int m_testCanMessage3{  }; // field identifier = 3.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::Test> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::Test> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_APPS_HPP
#define OPENDLV_CFSDPROXYCANREADING_APPS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API Apps {
    private:
        static constexpr const char* TheShortName = "Apps";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.Apps";

    public:
        inline static int32_t ID() {
            return 1002;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Apps() = default;
        Apps(const Apps&) = default;
        Apps& operator=(const Apps&) = default;
        Apps(Apps&&) = default;
        Apps& operator=(Apps&&) = default;
        ~Apps() = default;

    public:
        
        inline Apps& throttlePercentage(const float &v) noexcept {
            m_throttlePercentage = v;
            return *this;
        }
        inline float throttlePercentage() const noexcept {
            return m_throttlePercentage;
        }
        
        inline Apps& appsFault(const int &v) noexcept {
            m_appsFault = v;
            return *this;
        }
        inline int appsFault() const noexcept {
            return m_appsFault;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("throttlePercentage"s), m_throttlePercentage, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("appsFault"s), m_appsFault, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("throttlePercentage"s), m_throttlePercentage, visitor);
            
            doVisit(2, std::move("int"s), std::move("appsFault"s), m_appsFault, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("throttlePercentage"s), m_throttlePercentage, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("appsFault"s), m_appsFault, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_throttlePercentage{ 0.0f }; // field identifier = 1.
        
        int m_appsFault{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::Apps> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::Apps> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_ASSTATUS_HPP
#define OPENDLV_CFSDPROXYCANREADING_ASSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API AsStatus {
    private:
        static constexpr const char* TheShortName = "AsStatus";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.AsStatus";

    public:
        inline static int32_t ID() {
            return 2001;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        AsStatus() = default;
        AsStatus(const AsStatus&) = default;
        AsStatus& operator=(const AsStatus&) = default;
        AsStatus(AsStatus&&) = default;
        AsStatus& operator=(AsStatus&&) = default;
        ~AsStatus() = default;

    public:
        
        inline AsStatus& accSoC(const int &v) noexcept {
            m_accSoC = v;
            return *this;
        }
        inline int accSoC() const noexcept {
            return m_accSoC;
        }
        
        inline AsStatus& brakeRear(const int &v) noexcept {
            m_brakeRear = v;
            return *this;
        }
        inline int brakeRear() const noexcept {
            return m_brakeRear;
        }
        
        inline AsStatus& brakeFront(const int &v) noexcept {
            m_brakeFront = v;
            return *this;
        }
        inline int brakeFront() const noexcept {
            return m_brakeFront;
        }
        
        inline AsStatus& dlStatus(const int &v) noexcept {
            m_dlStatus = v;
            return *this;
        }
        inline int dlStatus() const noexcept {
            return m_dlStatus;
        }
        
        inline AsStatus& asMission(const int &v) noexcept {
            m_asMission = v;
            return *this;
        }
        inline int asMission() const noexcept {
            return m_asMission;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("accSoC"s), m_accSoC, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("brakeRear"s), m_brakeRear, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("brakeFront"s), m_brakeFront, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("int"s), std::move("dlStatus"s), m_dlStatus, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("int"s), std::move("asMission"s), m_asMission, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("accSoC"s), m_accSoC, visitor);
            
            doVisit(2, std::move("int"s), std::move("brakeRear"s), m_brakeRear, visitor);
            
            doVisit(3, std::move("int"s), std::move("brakeFront"s), m_brakeFront, visitor);
            
            doVisit(4, std::move("int"s), std::move("dlStatus"s), m_dlStatus, visitor);
            
            doVisit(5, std::move("int"s), std::move("asMission"s), m_asMission, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("accSoC"s), m_accSoC, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("brakeRear"s), m_brakeRear, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("brakeFront"s), m_brakeFront, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("int"s), std::move("dlStatus"s), m_dlStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("int"s), std::move("asMission"s), m_asMission, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_accSoC{  }; // field identifier = 1.
        
        int m_brakeRear{  }; // field identifier = 2.
        
        int m_brakeFront{  }; // field identifier = 3.
        
        int m_dlStatus{  }; // field identifier = 4.
        
        int m_asMission{  }; // field identifier = 5.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::AsStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::AsStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_WHEELSPEEDFRONT_HPP
#define OPENDLV_CFSDPROXYCANREADING_WHEELSPEEDFRONT_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API WheelSpeedFront {
    private:
        static constexpr const char* TheShortName = "WheelSpeedFront";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.WheelSpeedFront";

    public:
        inline static int32_t ID() {
            return 2002;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        WheelSpeedFront() = default;
        WheelSpeedFront(const WheelSpeedFront&) = default;
        WheelSpeedFront& operator=(const WheelSpeedFront&) = default;
        WheelSpeedFront(WheelSpeedFront&&) = default;
        WheelSpeedFront& operator=(WheelSpeedFront&&) = default;
        ~WheelSpeedFront() = default;

    public:
        
        inline WheelSpeedFront& wheelFrontRight(const float &v) noexcept {
            m_wheelFrontRight = v;
            return *this;
        }
        inline float wheelFrontRight() const noexcept {
            return m_wheelFrontRight;
        }
        
        inline WheelSpeedFront& wheelFrontLeft(const float &v) noexcept {
            m_wheelFrontLeft = v;
            return *this;
        }
        inline float wheelFrontLeft() const noexcept {
            return m_wheelFrontLeft;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, visitor);
            
            doVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_wheelFrontRight{ 0.0f }; // field identifier = 1.
        
        float m_wheelFrontLeft{ 0.0f }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::WheelSpeedFront> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::WheelSpeedFront> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_WHEELSPEEDRARE_HPP
#define OPENDLV_CFSDPROXYCANREADING_WHEELSPEEDRARE_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API WheelSpeedRare {
    private:
        static constexpr const char* TheShortName = "WheelSpeedRare";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.WheelSpeedRare";

    public:
        inline static int32_t ID() {
            return 2003;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        WheelSpeedRare() = default;
        WheelSpeedRare(const WheelSpeedRare&) = default;
        WheelSpeedRare& operator=(const WheelSpeedRare&) = default;
        WheelSpeedRare(WheelSpeedRare&&) = default;
        WheelSpeedRare& operator=(WheelSpeedRare&&) = default;
        ~WheelSpeedRare() = default;

    public:
        
        inline WheelSpeedRare& wheelRareRight(const float &v) noexcept {
            m_wheelRareRight = v;
            return *this;
        }
        inline float wheelRareRight() const noexcept {
            return m_wheelRareRight;
        }
        
        inline WheelSpeedRare& wheelRareLeft(const float &v) noexcept {
            m_wheelRareLeft = v;
            return *this;
        }
        inline float wheelRareLeft() const noexcept {
            return m_wheelRareLeft;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("wheelRareRight"s), m_wheelRareRight, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("wheelRareLeft"s), m_wheelRareLeft, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("wheelRareRight"s), m_wheelRareRight, visitor);
            
            doVisit(2, std::move("float"s), std::move("wheelRareLeft"s), m_wheelRareLeft, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("wheelRareRight"s), m_wheelRareRight, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("wheelRareLeft"s), m_wheelRareLeft, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_wheelRareRight{ 0.0f }; // field identifier = 1.
        
        float m_wheelRareLeft{ 0.0f }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::WheelSpeedRare> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::WheelSpeedRare> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_PEDALRATIO_HPP
#define OPENDLV_CFSDPROXYCANREADING_PEDALRATIO_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API PedalRatio {
    private:
        static constexpr const char* TheShortName = "PedalRatio";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.PedalRatio";

    public:
        inline static int32_t ID() {
            return 2004;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        PedalRatio() = default;
        PedalRatio(const PedalRatio&) = default;
        PedalRatio& operator=(const PedalRatio&) = default;
        PedalRatio(PedalRatio&&) = default;
        PedalRatio& operator=(PedalRatio&&) = default;
        ~PedalRatio() = default;

    public:
        
        inline PedalRatio& throttle(const int &v) noexcept {
            m_throttle = v;
            return *this;
        }
        inline int throttle() const noexcept {
            return m_throttle;
        }
        
        inline PedalRatio& brake(const int &v) noexcept {
            m_brake = v;
            return *this;
        }
        inline int brake() const noexcept {
            return m_brake;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("throttle"s), m_throttle, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("brake"s), m_brake, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("throttle"s), m_throttle, visitor);
            
            doVisit(2, std::move("int"s), std::move("brake"s), m_brake, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("throttle"s), m_throttle, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("brake"s), m_brake, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_throttle{  }; // field identifier = 1.
        
        int m_brake{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::PedalRatio> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::PedalRatio> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANWRITING_ASTORQUE_HPP
#define OPENDLV_CFSDPROXYCANWRITING_ASTORQUE_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API ASTorque {
    private:
        static constexpr const char* TheShortName = "ASTorque";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANWriting.ASTorque";

    public:
        inline static int32_t ID() {
            return 2005;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        ASTorque() = default;
        ASTorque(const ASTorque&) = default;
        ASTorque& operator=(const ASTorque&) = default;
        ASTorque(ASTorque&&) = default;
        ASTorque& operator=(ASTorque&&) = default;
        ~ASTorque() = default;

    public:
        
        inline ASTorque& torqueLeft(const int &v) noexcept {
            m_torqueLeft = v;
            return *this;
        }
        inline int torqueLeft() const noexcept {
            return m_torqueLeft;
        }
        
        inline ASTorque& torqueRight(const int &v) noexcept {
            m_torqueRight = v;
            return *this;
        }
        inline int torqueRight() const noexcept {
            return m_torqueRight;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("torqueLeft"s), m_torqueLeft, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("torqueRight"s), m_torqueRight, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("torqueLeft"s), m_torqueLeft, visitor);
            
            doVisit(2, std::move("int"s), std::move("torqueRight"s), m_torqueRight, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("torqueLeft"s), m_torqueLeft, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("torqueRight"s), m_torqueRight, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_torqueLeft{  }; // field identifier = 1.
        
        int m_torqueRight{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANWriting::ASTorque> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANWriting::ASTorque> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANWRITING_ASSTATUS_HPP
#define OPENDLV_CFSDPROXYCANWRITING_ASSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API ASStatus {
    private:
        static constexpr const char* TheShortName = "ASStatus";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANWriting.ASStatus";

    public:
        inline static int32_t ID() {
            return 2006;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        ASStatus() = default;
        ASStatus(const ASStatus&) = default;
        ASStatus& operator=(const ASStatus&) = default;
        ASStatus(ASStatus&&) = default;
        ASStatus& operator=(ASStatus&&) = default;
        ~ASStatus() = default;

    public:
        
        inline ASStatus& asRedyToDrive(const int &v) noexcept {
            m_asRedyToDrive = v;
            return *this;
        }
        inline int asRedyToDrive() const noexcept {
            return m_asRedyToDrive;
        }
        
        inline ASStatus& steeringPosition(const int &v) noexcept {
            m_steeringPosition = v;
            return *this;
        }
        inline int steeringPosition() const noexcept {
            return m_steeringPosition;
        }
        
        inline ASStatus& rackPosition(const int &v) noexcept {
            m_rackPosition = v;
            return *this;
        }
        inline int rackPosition() const noexcept {
            return m_rackPosition;
        }
        
        inline ASStatus& pressureService(const int &v) noexcept {
            m_pressureService = v;
            return *this;
        }
        inline int pressureService() const noexcept {
            return m_pressureService;
        }
        
        inline ASStatus& pressureRegulator(const int &v) noexcept {
            m_pressureRegulator = v;
            return *this;
        }
        inline int pressureRegulator() const noexcept {
            return m_pressureRegulator;
        }
        
        inline ASStatus& pressureEBSLine(const int &v) noexcept {
            m_pressureEBSLine = v;
            return *this;
        }
        inline int pressureEBSLine() const noexcept {
            return m_pressureEBSLine;
        }
        
        inline ASStatus& pressureEBSAct(const int &v) noexcept {
            m_pressureEBSAct = v;
            return *this;
        }
        inline int pressureEBSAct() const noexcept {
            return m_pressureEBSAct;
        }
        
        inline ASStatus& asState(const int &v) noexcept {
            m_asState = v;
            return *this;
        }
        inline int asState() const noexcept {
            return m_asState;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("asRedyToDrive"s), m_asRedyToDrive, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("steeringPosition"s), m_steeringPosition, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("rackPosition"s), m_rackPosition, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("int"s), std::move("pressureService"s), m_pressureService, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("int"s), std::move("pressureRegulator"s), m_pressureRegulator, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("int"s), std::move("pressureEBSLine"s), m_pressureEBSLine, visitor);
                return;
            }
            
            if (7 == fieldId) {
                doVisit(7, std::move("int"s), std::move("pressureEBSAct"s), m_pressureEBSAct, visitor);
                return;
            }
            
            if (8 == fieldId) {
                doVisit(8, std::move("int"s), std::move("asState"s), m_asState, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("asRedyToDrive"s), m_asRedyToDrive, visitor);
            
            doVisit(2, std::move("int"s), std::move("steeringPosition"s), m_steeringPosition, visitor);
            
            doVisit(3, std::move("int"s), std::move("rackPosition"s), m_rackPosition, visitor);
            
            doVisit(4, std::move("int"s), std::move("pressureService"s), m_pressureService, visitor);
            
            doVisit(5, std::move("int"s), std::move("pressureRegulator"s), m_pressureRegulator, visitor);
            
            doVisit(6, std::move("int"s), std::move("pressureEBSLine"s), m_pressureEBSLine, visitor);
            
            doVisit(7, std::move("int"s), std::move("pressureEBSAct"s), m_pressureEBSAct, visitor);
            
            doVisit(8, std::move("int"s), std::move("asState"s), m_asState, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("asRedyToDrive"s), m_asRedyToDrive, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("steeringPosition"s), m_steeringPosition, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("rackPosition"s), m_rackPosition, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("int"s), std::move("pressureService"s), m_pressureService, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("int"s), std::move("pressureRegulator"s), m_pressureRegulator, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("int"s), std::move("pressureEBSLine"s), m_pressureEBSLine, preVisit, visit, postVisit);
            
            doTripletForwardVisit(7, std::move("int"s), std::move("pressureEBSAct"s), m_pressureEBSAct, preVisit, visit, postVisit);
            
            doTripletForwardVisit(8, std::move("int"s), std::move("asState"s), m_asState, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_asRedyToDrive{  }; // field identifier = 1.
        
        int m_steeringPosition{  }; // field identifier = 2.
        
        int m_rackPosition{  }; // field identifier = 3.
        
        int m_pressureService{  }; // field identifier = 4.
        
        int m_pressureRegulator{  }; // field identifier = 5.
        
        int m_pressureEBSLine{  }; // field identifier = 6.
        
        int m_pressureEBSAct{  }; // field identifier = 7.
        
        int m_asState{  }; // field identifier = 8.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANWriting::ASStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANWriting::ASStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANWRITING_NMT_HPP
#define OPENDLV_CFSDPROXYCANWRITING_NMT_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API NMT {
    private:
        static constexpr const char* TheShortName = "NMT";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANWriting.NMT";

    public:
        inline static int32_t ID() {
            return 2007;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        NMT() = default;
        NMT(const NMT&) = default;
        NMT& operator=(const NMT&) = default;
        NMT(NMT&&) = default;
        NMT& operator=(NMT&&) = default;
        ~NMT() = default;

    public:
        
        inline NMT& nodeState(const uint8_t &v) noexcept {
            m_nodeState = v;
            return *this;
        }
        inline uint8_t nodeState() const noexcept {
            return m_nodeState;
        }
        
        inline NMT& nodeId(const uint8_t &v) noexcept {
            m_nodeId = v;
            return *this;
        }
        inline uint8_t nodeId() const noexcept {
            return m_nodeId;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("uint8_t"s), std::move("nodeState"s), m_nodeState, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("uint8_t"s), std::move("nodeId"s), m_nodeId, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("uint8_t"s), std::move("nodeState"s), m_nodeState, visitor);
            
            doVisit(2, std::move("uint8_t"s), std::move("nodeId"s), m_nodeId, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("uint8_t"s), std::move("nodeState"s), m_nodeState, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("uint8_t"s), std::move("nodeId"s), m_nodeId, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        uint8_t m_nodeState{ 0 }; // field identifier = 1.
        
        uint8_t m_nodeId{ 0 }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANWriting::NMT> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANWriting::NMT> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_RESSTATUS_HPP
#define OPENDLV_CFSDPROXYCANREADING_RESSTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API RESStatus {
    private:
        static constexpr const char* TheShortName = "RESStatus";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.RESStatus";

    public:
        inline static int32_t ID() {
            return 2008;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        RESStatus() = default;
        RESStatus(const RESStatus&) = default;
        RESStatus& operator=(const RESStatus&) = default;
        RESStatus(RESStatus&&) = default;
        RESStatus& operator=(RESStatus&&) = default;
        ~RESStatus() = default;

    public:
        
        inline RESStatus& resStatus(const int &v) noexcept {
            m_resStatus = v;
            return *this;
        }
        inline int resStatus() const noexcept {
            return m_resStatus;
        }
        
        inline RESStatus& resEStop(const int &v) noexcept {
            m_resEStop = v;
            return *this;
        }
        inline int resEStop() const noexcept {
            return m_resEStop;
        }
        
        inline RESStatus& resQuality(const int &v) noexcept {
            m_resQuality = v;
            return *this;
        }
        inline int resQuality() const noexcept {
            return m_resQuality;
        }
        
        inline RESStatus& resButtons(const int &v) noexcept {
            m_resButtons = v;
            return *this;
        }
        inline int resButtons() const noexcept {
            return m_resButtons;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("resStatus"s), m_resStatus, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("resEStop"s), m_resEStop, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("resQuality"s), m_resQuality, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("int"s), std::move("resButtons"s), m_resButtons, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("resStatus"s), m_resStatus, visitor);
            
            doVisit(2, std::move("int"s), std::move("resEStop"s), m_resEStop, visitor);
            
            doVisit(3, std::move("int"s), std::move("resQuality"s), m_resQuality, visitor);
            
            doVisit(4, std::move("int"s), std::move("resButtons"s), m_resButtons, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("resStatus"s), m_resStatus, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("resEStop"s), m_resEStop, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("resQuality"s), m_resQuality, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("int"s), std::move("resButtons"s), m_resButtons, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_resStatus{  }; // field identifier = 1.
        
        int m_resEStop{  }; // field identifier = 2.
        
        int m_resQuality{  }; // field identifier = 3.
        
        int m_resButtons{  }; // field identifier = 4.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::RESStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::RESStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_KNOBS_HPP
#define OPENDLV_CFSDPROXYCANREADING_KNOBS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API Knobs {
    private:
        static constexpr const char* TheShortName = "Knobs";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.Knobs";

    public:
        inline static int32_t ID() {
            return 2009;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Knobs() = default;
        Knobs(const Knobs&) = default;
        Knobs& operator=(const Knobs&) = default;
        Knobs(Knobs&&) = default;
        Knobs& operator=(Knobs&&) = default;
        ~Knobs() = default;

    public:
        
        inline Knobs& knobL(const int &v) noexcept {
            m_knobL = v;
            return *this;
        }
        inline int knobL() const noexcept {
            return m_knobL;
        }
        
        inline Knobs& knobR(const int &v) noexcept {
            m_knobR = v;
            return *this;
        }
        inline int knobR() const noexcept {
            return m_knobR;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("knobL"s), m_knobL, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("knobR"s), m_knobR, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("knobL"s), m_knobL, visitor);
            
            doVisit(2, std::move("int"s), std::move("knobR"s), m_knobR, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("knobL"s), m_knobL, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("knobR"s), m_knobR, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_knobL{  }; // field identifier = 1.
        
        int m_knobR{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::Knobs> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::Knobs> {
    static const bool value = true;
};
#endif

