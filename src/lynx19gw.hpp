/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Wed Aug  5 09:26:49 2020.
 */

#ifndef LYNX19GW_H
#define LYNX19GW_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifndef EINVAL
#    define EINVAL 22
#endif

#define LYNX19GW_MOTOR_CONTROL_MESSAGE_FRAME_ID (0x10u)
#define LYNX19GW_FRONT_NODE_STATUS_FRAME_ID (0x1fu)
#define LYNX19GW_REAR_NODE_STATUS_FRAME_ID (0x20u)
#define LYNX19GW_AUTONOMOUS_NODE_STATUS_FRAME_ID (0x21u)
#define LYNX19GW_AMS_STATUS_FRAME_ID (0x22u)
#define LYNX19GW_APPS_1_FRAME_ID (0x1f5u)
#define LYNX19GW_APPS_2_FRAME_ID (0x1f6u)
#define LYNX19GW_HYDRAULIC_BRAKE_PRESSURE_1_FRAME_ID (0x1f7u)
#define LYNX19GW_HYDRAULIC_BRAKE_PRESSURE_2_FRAME_ID (0x1f8u)
#define LYNX19GW_BRAKE_DISK_TEMP_1_FRAME_ID (0x1f9u)
#define LYNX19GW_BRAKE_DISK_TEMP_2_FRAME_ID (0x1fau)
#define LYNX19GW_DAMPER_POSITION_1_FRAME_ID (0x1fbu)
#define LYNX19GW_DAMPER_POSITION_2_FRAME_ID (0x1fcu)
#define LYNX19GW_PNUEMATIC_PRESSURE_1_FRAME_ID (0x1fdu)
#define LYNX19GW_PNUEMATIC_PRESSURE_2_FRAME_ID (0x1feu)
#define LYNX19GW_PNUEMATIC_PRESSURE_3_FRAME_ID (0x1ffu)
#define LYNX19GW_STEERING_POSITION_1_FRAME_ID (0x200u)
#define LYNX19GW_STEERING_POSITION_2_FRAME_ID (0x201u)
#define LYNX19GW_TEST_CAN_MESSAGE_1_FRAME_ID (0xc8u)
#define LYNX19GW_TEST_CAN_MESSAGE_2_FRAME_ID (0xc9u)
#define LYNX19GW_TEST_CAN_MESSAGE_3_FRAME_ID (0xcau)
#define LYNX19GW_SAFETY_LAYER_FRAME_ID (0x7d1u)
#define LYNX19GW_VEHICLE_SPEED_FRAME_ID (0x7d2u)
#define LYNX19GW_EBS_FRAME_ID (0x7d3u)
#define LYNX19GW_AS_MISSION_FRAME_ID (0x7d5u)

/**
 * Signals in message MOTOR_CONTROL_MESSAGE.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_motor_control_message_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t pwm_enabled;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t torque_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t speed_setpoint;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint16_t max_power_setpoint;
};

/**
 * Signals in message FRONT_NODE_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_front_node_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message REAR_NODE_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_rear_node_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message AUTONOMOUS_NODE_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_autonomous_node_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message AMS_STATUS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_ams_status_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t counter;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    int8_t ready_to_drive;
};

/**
 * Signals in message APPS_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_apps_1_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float throttle_percentage;
};

/**
 * Signals in message APPS_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_apps_2_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float throttle_percentage;
};

/**
 * Signals in message HYDRAULIC_BRAKE_PRESSURE_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_hydraulic_brake_pressure_1_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float hydraulic_pressure;
};

/**
 * Signals in message HYDRAULIC_BRAKE_PRESSURE_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_hydraulic_brake_pressure_2_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float hydraulic_pressure;
};

/**
 * Signals in message BRAKE_DISK_TEMP_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_brake_disk_temp_1_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float brake_disk_temp;
};

/**
 * Signals in message BRAKE_DISK_TEMP_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_brake_disk_temp_2_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float brake_disk_temp;
};

/**
 * Signals in message DAMPER_POSITION_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_damper_position_1_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float damper_position;
};

/**
 * Signals in message DAMPER_POSITION_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_damper_position_2_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float damper_position;
};

/**
 * Signals in message PNUEMATIC_PRESSURE_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_pnuematic_pressure_1_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float pnuematic_pressure;
};

/**
 * Signals in message PNUEMATIC_PRESSURE_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_pnuematic_pressure_2_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float pnuematic_pressure;
};

/**
 * Signals in message PNUEMATIC_PRESSURE_3.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_pnuematic_pressure_3_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float pnuematic_pressure;
};

/**
 * Signals in message STEERING_POSITION_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_steering_position_1_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float steering_position;
};

/**
 * Signals in message STEERING_POSITION_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_steering_position_2_t {
    /**
     * Range: 0..100 (0.0..100.0 per)
     * Scale: 1
     * Offset: 0
     */
    float steering_position;
};

/**
 * Signals in message TEST_CAN_MESSAGE_1.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_test_can_message_1_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_message;
};

/**
 * Signals in message TEST_CAN_MESSAGE_2.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_test_can_message_2_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_message;
};

/**
 * Signals in message TEST_CAN_MESSAGE_3.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_test_can_message_3_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t test_message;
};

/**
 * Signals in message SAFETY_LAYER.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_safety_layer_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t asms_on;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_state;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_stop_signal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_go_signal;

    /**
     * Range: 0..1 (0..1 -)
     * Scale: 1
     * Offset: 0
     */
    uint8_t res_initialized;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t brakes_released;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ts_on;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t as_heartbeat;
};

/**
 * Signals in message VEHICLE_SPEED.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_vehicle_speed_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float wheel_front_right;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    float wheel_front_left;
};

/**
 * Signals in message EBS.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_ebs_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_state;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_armed;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_activated;

    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t ebs_speaker_on;
};

/**
 * Signals in message AS_MISSION.
 *
 * All signal values are as on the CAN bus.
 */
struct lynx19gw_as_mission_t {
    /**
     * Range: -
     * Scale: 1
     * Offset: 0
     */
    uint8_t mission_select;
};

/**
 * Pack message MOTOR_CONTROL_MESSAGE.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_motor_control_message_pack(
    uint8_t *dst_p,
    const struct lynx19gw_motor_control_message_t *src_p,
    size_t size);

/**
 * Unpack message MOTOR_CONTROL_MESSAGE.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_motor_control_message_unpack(
    struct lynx19gw_motor_control_message_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_motor_control_message_pwm_enabled_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_pwm_enabled_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_pwm_enabled_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_motor_control_message_torque_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_torque_setpoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_torque_setpoint_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_motor_control_message_speed_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_speed_setpoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_speed_setpoint_is_in_range(uint16_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint16_t lynx19gw_motor_control_message_max_power_setpoint_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_motor_control_message_max_power_setpoint_decode(uint16_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_motor_control_message_max_power_setpoint_is_in_range(uint16_t value);

/**
 * Pack message FRONT_NODE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_front_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_front_node_status_t *src_p,
    size_t size);

/**
 * Unpack message FRONT_NODE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_front_node_status_unpack(
    struct lynx19gw_front_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_front_node_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_front_node_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_front_node_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_front_node_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_front_node_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_front_node_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message REAR_NODE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_rear_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_rear_node_status_t *src_p,
    size_t size);

/**
 * Unpack message REAR_NODE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_rear_node_status_unpack(
    struct lynx19gw_rear_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_rear_node_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_rear_node_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_rear_node_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_rear_node_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_rear_node_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_rear_node_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message AUTONOMOUS_NODE_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_autonomous_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_autonomous_node_status_t *src_p,
    size_t size);

/**
 * Unpack message AUTONOMOUS_NODE_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_autonomous_node_status_unpack(
    struct lynx19gw_autonomous_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_autonomous_node_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_autonomous_node_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_autonomous_node_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_autonomous_node_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_autonomous_node_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_autonomous_node_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message AMS_STATUS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_ams_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_ams_status_t *src_p,
    size_t size);

/**
 * Unpack message AMS_STATUS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_ams_status_unpack(
    struct lynx19gw_ams_status_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_ams_status_counter_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ams_status_counter_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ams_status_counter_is_in_range(int8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline int8_t lynx19gw_ams_status_ready_to_drive_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ams_status_ready_to_drive_decode(int8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ams_status_ready_to_drive_is_in_range(int8_t value);

/**
 * Pack message APPS_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_apps_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_apps_1_t *src_p,
    size_t size);

/**
 * Unpack message APPS_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_apps_1_unpack(
    struct lynx19gw_apps_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_apps_1_throttle_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_apps_1_throttle_percentage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_apps_1_throttle_percentage_is_in_range(float value);

/**
 * Pack message APPS_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_apps_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_apps_2_t *src_p,
    size_t size);

/**
 * Unpack message APPS_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_apps_2_unpack(
    struct lynx19gw_apps_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_apps_2_throttle_percentage_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_apps_2_throttle_percentage_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_apps_2_throttle_percentage_is_in_range(float value);

/**
 * Pack message HYDRAULIC_BRAKE_PRESSURE_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_hydraulic_brake_pressure_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_hydraulic_brake_pressure_1_t *src_p,
    size_t size);

/**
 * Unpack message HYDRAULIC_BRAKE_PRESSURE_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_hydraulic_brake_pressure_1_unpack(
    struct lynx19gw_hydraulic_brake_pressure_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_hydraulic_brake_pressure_1_hydraulic_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_hydraulic_brake_pressure_1_hydraulic_pressure_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_hydraulic_brake_pressure_1_hydraulic_pressure_is_in_range(float value);

/**
 * Pack message HYDRAULIC_BRAKE_PRESSURE_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_hydraulic_brake_pressure_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_hydraulic_brake_pressure_2_t *src_p,
    size_t size);

/**
 * Unpack message HYDRAULIC_BRAKE_PRESSURE_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_hydraulic_brake_pressure_2_unpack(
    struct lynx19gw_hydraulic_brake_pressure_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_hydraulic_brake_pressure_2_hydraulic_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_hydraulic_brake_pressure_2_hydraulic_pressure_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_hydraulic_brake_pressure_2_hydraulic_pressure_is_in_range(float value);

/**
 * Pack message BRAKE_DISK_TEMP_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_brake_disk_temp_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_brake_disk_temp_1_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE_DISK_TEMP_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_brake_disk_temp_1_unpack(
    struct lynx19gw_brake_disk_temp_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_brake_disk_temp_1_brake_disk_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_brake_disk_temp_1_brake_disk_temp_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_brake_disk_temp_1_brake_disk_temp_is_in_range(float value);

/**
 * Pack message BRAKE_DISK_TEMP_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_brake_disk_temp_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_brake_disk_temp_2_t *src_p,
    size_t size);

/**
 * Unpack message BRAKE_DISK_TEMP_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_brake_disk_temp_2_unpack(
    struct lynx19gw_brake_disk_temp_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_brake_disk_temp_2_brake_disk_temp_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_brake_disk_temp_2_brake_disk_temp_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_brake_disk_temp_2_brake_disk_temp_is_in_range(float value);

/**
 * Pack message DAMPER_POSITION_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_damper_position_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_damper_position_1_t *src_p,
    size_t size);

/**
 * Unpack message DAMPER_POSITION_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_damper_position_1_unpack(
    struct lynx19gw_damper_position_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_damper_position_1_damper_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_damper_position_1_damper_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_damper_position_1_damper_position_is_in_range(float value);

/**
 * Pack message DAMPER_POSITION_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_damper_position_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_damper_position_2_t *src_p,
    size_t size);

/**
 * Unpack message DAMPER_POSITION_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_damper_position_2_unpack(
    struct lynx19gw_damper_position_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_damper_position_2_damper_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_damper_position_2_damper_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_damper_position_2_damper_position_is_in_range(float value);

/**
 * Pack message PNUEMATIC_PRESSURE_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_pnuematic_pressure_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pnuematic_pressure_1_t *src_p,
    size_t size);

/**
 * Unpack message PNUEMATIC_PRESSURE_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_pnuematic_pressure_1_unpack(
    struct lynx19gw_pnuematic_pressure_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_pnuematic_pressure_1_pnuematic_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pnuematic_pressure_1_pnuematic_pressure_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pnuematic_pressure_1_pnuematic_pressure_is_in_range(float value);

/**
 * Pack message PNUEMATIC_PRESSURE_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_pnuematic_pressure_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pnuematic_pressure_2_t *src_p,
    size_t size);

/**
 * Unpack message PNUEMATIC_PRESSURE_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_pnuematic_pressure_2_unpack(
    struct lynx19gw_pnuematic_pressure_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_pnuematic_pressure_2_pnuematic_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pnuematic_pressure_2_pnuematic_pressure_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pnuematic_pressure_2_pnuematic_pressure_is_in_range(float value);

/**
 * Pack message PNUEMATIC_PRESSURE_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_pnuematic_pressure_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pnuematic_pressure_3_t *src_p,
    size_t size);

/**
 * Unpack message PNUEMATIC_PRESSURE_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_pnuematic_pressure_3_unpack(
    struct lynx19gw_pnuematic_pressure_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_pnuematic_pressure_3_pnuematic_pressure_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_pnuematic_pressure_3_pnuematic_pressure_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_pnuematic_pressure_3_pnuematic_pressure_is_in_range(float value);

/**
 * Pack message STEERING_POSITION_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_steering_position_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_steering_position_1_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_POSITION_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_steering_position_1_unpack(
    struct lynx19gw_steering_position_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_steering_position_1_steering_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_steering_position_1_steering_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_steering_position_1_steering_position_is_in_range(float value);

/**
 * Pack message STEERING_POSITION_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_steering_position_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_steering_position_2_t *src_p,
    size_t size);

/**
 * Unpack message STEERING_POSITION_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_steering_position_2_unpack(
    struct lynx19gw_steering_position_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_steering_position_2_steering_position_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_steering_position_2_steering_position_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_steering_position_2_steering_position_is_in_range(float value);

/**
 * Pack message TEST_CAN_MESSAGE_1.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_test_can_message_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_1_t *src_p,
    size_t size);

/**
 * Unpack message TEST_CAN_MESSAGE_1.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_test_can_message_1_unpack(
    struct lynx19gw_test_can_message_1_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_test_can_message_1_test_message_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_test_can_message_1_test_message_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_test_can_message_1_test_message_is_in_range(uint8_t value);

/**
 * Pack message TEST_CAN_MESSAGE_2.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_test_can_message_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_2_t *src_p,
    size_t size);

/**
 * Unpack message TEST_CAN_MESSAGE_2.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_test_can_message_2_unpack(
    struct lynx19gw_test_can_message_2_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_test_can_message_2_test_message_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_test_can_message_2_test_message_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_test_can_message_2_test_message_is_in_range(uint8_t value);

/**
 * Pack message TEST_CAN_MESSAGE_3.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_test_can_message_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_3_t *src_p,
    size_t size);

/**
 * Unpack message TEST_CAN_MESSAGE_3.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_test_can_message_3_unpack(
    struct lynx19gw_test_can_message_3_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_test_can_message_3_test_message_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_test_can_message_3_test_message_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_test_can_message_3_test_message_is_in_range(uint8_t value);

/**
 * Pack message SAFETY_LAYER.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_safety_layer_pack(
    uint8_t *dst_p,
    const struct lynx19gw_safety_layer_t *src_p,
    size_t size);

/**
 * Unpack message SAFETY_LAYER.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_safety_layer_unpack(
    struct lynx19gw_safety_layer_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_as_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_as_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_as_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_asms_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_asms_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_asms_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_res_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_res_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_res_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_res_stop_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_res_stop_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_res_stop_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_res_go_signal_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_res_go_signal_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_res_go_signal_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_res_initialized_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_res_initialized_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_res_initialized_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_brakes_released_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_brakes_released_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_brakes_released_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_ts_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_ts_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_ts_on_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_safety_layer_as_heartbeat_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_safety_layer_as_heartbeat_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_safety_layer_as_heartbeat_is_in_range(uint8_t value);

/**
 * Pack message VEHICLE_SPEED.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_vehicle_speed_pack(
    uint8_t *dst_p,
    const struct lynx19gw_vehicle_speed_t *src_p,
    size_t size);

/**
 * Unpack message VEHICLE_SPEED.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_vehicle_speed_unpack(
    struct lynx19gw_vehicle_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_vehicle_speed_wheel_front_right_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_vehicle_speed_wheel_front_right_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_vehicle_speed_wheel_front_right_is_in_range(float value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline float lynx19gw_vehicle_speed_wheel_front_left_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_vehicle_speed_wheel_front_left_decode(float value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_vehicle_speed_wheel_front_left_is_in_range(float value);

/**
 * Pack message EBS.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_ebs_pack(
    uint8_t *dst_p,
    const struct lynx19gw_ebs_t *src_p,
    size_t size);

/**
 * Unpack message EBS.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_ebs_unpack(
    struct lynx19gw_ebs_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_ebs_ebs_state_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ebs_ebs_state_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ebs_ebs_state_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_ebs_ebs_armed_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ebs_ebs_armed_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ebs_ebs_armed_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_ebs_ebs_activated_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ebs_ebs_activated_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ebs_ebs_activated_is_in_range(uint8_t value);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_ebs_ebs_speaker_on_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_ebs_ebs_speaker_on_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_ebs_ebs_speaker_on_is_in_range(uint8_t value);

/**
 * Pack message AS_MISSION.
 *
 * @param[out] dst_p Buffer to pack the message into.
 * @param[in] src_p Data to pack.
 * @param[in] size Size of dst_p.
 *
 * @return Size of packed data, or negative error code.
 */
inline int lynx19gw_as_mission_pack(
    uint8_t *dst_p,
    const struct lynx19gw_as_mission_t *src_p,
    size_t size);

/**
 * Unpack message AS_MISSION.
 *
 * @param[out] dst_p Object to unpack the message into.
 * @param[in] src_p Message to unpack.
 * @param[in] size Size of src_p.
 *
 * @return zero(0) or negative error code.
 */
inline int lynx19gw_as_mission_unpack(
    struct lynx19gw_as_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size);

/**
 * Encode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to encode.
 *
 * @return Encoded signal.
 */
inline uint8_t lynx19gw_as_mission_mission_select_encode(double value);

/**
 * Decode given signal by applying scaling and offset.
 *
 * @param[in] value Signal to decode.
 *
 * @return Decoded signal.
 */
inline double lynx19gw_as_mission_mission_select_decode(uint8_t value);

/**
 * Check that given signal is in allowed range.
 *
 * @param[in] value Signal to check.
 *
 * @return true if in range, false otherwise.
 */
inline bool lynx19gw_as_mission_mission_select_is_in_range(uint8_t value);

#endif
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2019 Erik Moqvist
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
 * This file was generated by cantools version 32.6.3 Wed Aug  5 09:26:49 2020.
 */

#include <string.h>

//#include "lynx19gw.h"

static inline uint8_t pack_left_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_left_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value << shift) & mask);
}

static inline uint8_t pack_right_shift_u16(
    uint16_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint8_t pack_right_shift_u32(
    uint32_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value >> shift) & mask);
}

static inline uint16_t unpack_left_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) << shift);
}

static inline uint32_t unpack_left_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) << shift);
}

static inline uint8_t unpack_right_shift_u8(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint8_t)((uint8_t)(value & mask) >> shift);
}

static inline uint16_t unpack_right_shift_u16(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint16_t)((uint16_t)(value & mask) >> shift);
}

static inline uint32_t unpack_right_shift_u32(
    uint8_t value,
    uint8_t shift,
    uint8_t mask)
{
    return (uint32_t)((uint32_t)(value & mask) >> shift);
}

int lynx19gw_motor_control_message_pack(
    uint8_t *dst_p,
    const struct lynx19gw_motor_control_message_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 7);

    dst_p[0] |= pack_left_shift_u8(src_p->pwm_enabled, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u16(src_p->torque_setpoint, 0u, 0xffu);
    dst_p[2] |= pack_right_shift_u16(src_p->torque_setpoint, 8u, 0xffu);
    dst_p[3] |= pack_left_shift_u16(src_p->speed_setpoint, 0u, 0xffu);
    dst_p[4] |= pack_right_shift_u16(src_p->speed_setpoint, 8u, 0xffu);
    dst_p[5] |= pack_left_shift_u16(src_p->max_power_setpoint, 0u, 0xffu);
    dst_p[6] |= pack_right_shift_u16(src_p->max_power_setpoint, 8u, 0xffu);

    return (7);
}

int lynx19gw_motor_control_message_unpack(
    struct lynx19gw_motor_control_message_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 7u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->pwm_enabled |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->torque_setpoint |= unpack_right_shift_u16(src_p[1], 0u, 0xffu);
    dst_p->torque_setpoint |= unpack_left_shift_u16(src_p[2], 8u, 0xffu);
    dst_p->speed_setpoint |= unpack_right_shift_u16(src_p[3], 0u, 0xffu);
    dst_p->speed_setpoint |= unpack_left_shift_u16(src_p[4], 8u, 0xffu);
    dst_p->max_power_setpoint |= unpack_right_shift_u16(src_p[5], 0u, 0xffu);
    dst_p->max_power_setpoint |= unpack_left_shift_u16(src_p[6], 8u, 0xffu);

    return (0);
}

uint8_t lynx19gw_motor_control_message_pwm_enabled_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_motor_control_message_pwm_enabled_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_pwm_enabled_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_motor_control_message_torque_setpoint_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_motor_control_message_torque_setpoint_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_torque_setpoint_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_motor_control_message_speed_setpoint_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_motor_control_message_speed_setpoint_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_speed_setpoint_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

uint16_t lynx19gw_motor_control_message_max_power_setpoint_encode(double value)
{
    return (uint16_t)(value);
}

double lynx19gw_motor_control_message_max_power_setpoint_decode(uint16_t value)
{
    return ((double)value);
}

bool lynx19gw_motor_control_message_max_power_setpoint_is_in_range(uint16_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_front_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_front_node_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_front_node_status_unpack(
    struct lynx19gw_front_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_front_node_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_front_node_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_front_node_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_front_node_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_front_node_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_front_node_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_rear_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_rear_node_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_rear_node_status_unpack(
    struct lynx19gw_rear_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_rear_node_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_rear_node_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_rear_node_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_rear_node_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_rear_node_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_rear_node_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_autonomous_node_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_autonomous_node_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_autonomous_node_status_unpack(
    struct lynx19gw_autonomous_node_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_autonomous_node_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_autonomous_node_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_autonomous_node_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_autonomous_node_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_autonomous_node_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_autonomous_node_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_ams_status_pack(
    uint8_t *dst_p,
    const struct lynx19gw_ams_status_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    counter = (uint8_t)src_p->counter;
    dst_p[0] |= pack_left_shift_u8(counter, 0u, 0xffu);
    ready_to_drive = (uint8_t)src_p->ready_to_drive;
    dst_p[1] |= pack_left_shift_u8(ready_to_drive, 0u, 0xffu);

    return (2);
}

int lynx19gw_ams_status_unpack(
    struct lynx19gw_ams_status_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint8_t counter;
    uint8_t ready_to_drive;

    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    counter = 0u;
    counter |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->counter = (int8_t)counter;
    ready_to_drive = 0u;
    ready_to_drive |= unpack_right_shift_u8(src_p[1], 0u, 0xffu);
    dst_p->ready_to_drive = (int8_t)ready_to_drive;

    return (0);
}

int8_t lynx19gw_ams_status_counter_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_ams_status_counter_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_ams_status_counter_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int8_t lynx19gw_ams_status_ready_to_drive_encode(double value)
{
    return (int8_t)(value);
}

double lynx19gw_ams_status_ready_to_drive_decode(int8_t value)
{
    return ((double)value);
}

bool lynx19gw_ams_status_ready_to_drive_is_in_range(int8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_apps_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_apps_1_t *src_p,
    size_t size)
{
    uint32_t throttle_percentage;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&throttle_percentage, &src_p->throttle_percentage, sizeof(throttle_percentage));
    dst_p[0] |= pack_left_shift_u32(throttle_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_percentage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_percentage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_percentage, 24u, 0xffu);

    return (4);
}

int lynx19gw_apps_1_unpack(
    struct lynx19gw_apps_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_percentage;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    throttle_percentage = 0u;
    throttle_percentage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_percentage, &throttle_percentage, sizeof(dst_p->throttle_percentage));

    return (0);
}

float lynx19gw_apps_1_throttle_percentage_encode(double value)
{
    return (float)(value);
}

double lynx19gw_apps_1_throttle_percentage_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_apps_1_throttle_percentage_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_apps_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_apps_2_t *src_p,
    size_t size)
{
    uint32_t throttle_percentage;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&throttle_percentage, &src_p->throttle_percentage, sizeof(throttle_percentage));
    dst_p[0] |= pack_left_shift_u32(throttle_percentage, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(throttle_percentage, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(throttle_percentage, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(throttle_percentage, 24u, 0xffu);

    return (4);
}

int lynx19gw_apps_2_unpack(
    struct lynx19gw_apps_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t throttle_percentage;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    throttle_percentage = 0u;
    throttle_percentage |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    throttle_percentage |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->throttle_percentage, &throttle_percentage, sizeof(dst_p->throttle_percentage));

    return (0);
}

float lynx19gw_apps_2_throttle_percentage_encode(double value)
{
    return (float)(value);
}

double lynx19gw_apps_2_throttle_percentage_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_apps_2_throttle_percentage_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_hydraulic_brake_pressure_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_hydraulic_brake_pressure_1_t *src_p,
    size_t size)
{
    uint32_t hydraulic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&hydraulic_pressure, &src_p->hydraulic_pressure, sizeof(hydraulic_pressure));
    dst_p[0] |= pack_left_shift_u32(hydraulic_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(hydraulic_pressure, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(hydraulic_pressure, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(hydraulic_pressure, 24u, 0xffu);

    return (4);
}

int lynx19gw_hydraulic_brake_pressure_1_unpack(
    struct lynx19gw_hydraulic_brake_pressure_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t hydraulic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    hydraulic_pressure = 0u;
    hydraulic_pressure |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    hydraulic_pressure |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    hydraulic_pressure |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    hydraulic_pressure |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->hydraulic_pressure, &hydraulic_pressure, sizeof(dst_p->hydraulic_pressure));

    return (0);
}

float lynx19gw_hydraulic_brake_pressure_1_hydraulic_pressure_encode(double value)
{
    return (float)(value);
}

double lynx19gw_hydraulic_brake_pressure_1_hydraulic_pressure_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_hydraulic_brake_pressure_1_hydraulic_pressure_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_hydraulic_brake_pressure_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_hydraulic_brake_pressure_2_t *src_p,
    size_t size)
{
    uint32_t hydraulic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&hydraulic_pressure, &src_p->hydraulic_pressure, sizeof(hydraulic_pressure));
    dst_p[0] |= pack_left_shift_u32(hydraulic_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(hydraulic_pressure, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(hydraulic_pressure, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(hydraulic_pressure, 24u, 0xffu);

    return (4);
}

int lynx19gw_hydraulic_brake_pressure_2_unpack(
    struct lynx19gw_hydraulic_brake_pressure_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t hydraulic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    hydraulic_pressure = 0u;
    hydraulic_pressure |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    hydraulic_pressure |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    hydraulic_pressure |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    hydraulic_pressure |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->hydraulic_pressure, &hydraulic_pressure, sizeof(dst_p->hydraulic_pressure));

    return (0);
}

float lynx19gw_hydraulic_brake_pressure_2_hydraulic_pressure_encode(double value)
{
    return (float)(value);
}

double lynx19gw_hydraulic_brake_pressure_2_hydraulic_pressure_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_hydraulic_brake_pressure_2_hydraulic_pressure_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_brake_disk_temp_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_brake_disk_temp_1_t *src_p,
    size_t size)
{
    uint32_t brake_disk_temp;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&brake_disk_temp, &src_p->brake_disk_temp, sizeof(brake_disk_temp));
    dst_p[0] |= pack_left_shift_u32(brake_disk_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(brake_disk_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(brake_disk_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(brake_disk_temp, 24u, 0xffu);

    return (4);
}

int lynx19gw_brake_disk_temp_1_unpack(
    struct lynx19gw_brake_disk_temp_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t brake_disk_temp;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    brake_disk_temp = 0u;
    brake_disk_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    brake_disk_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    brake_disk_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    brake_disk_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->brake_disk_temp, &brake_disk_temp, sizeof(dst_p->brake_disk_temp));

    return (0);
}

float lynx19gw_brake_disk_temp_1_brake_disk_temp_encode(double value)
{
    return (float)(value);
}

double lynx19gw_brake_disk_temp_1_brake_disk_temp_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_brake_disk_temp_1_brake_disk_temp_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_brake_disk_temp_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_brake_disk_temp_2_t *src_p,
    size_t size)
{
    uint32_t brake_disk_temp;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&brake_disk_temp, &src_p->brake_disk_temp, sizeof(brake_disk_temp));
    dst_p[0] |= pack_left_shift_u32(brake_disk_temp, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(brake_disk_temp, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(brake_disk_temp, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(brake_disk_temp, 24u, 0xffu);

    return (4);
}

int lynx19gw_brake_disk_temp_2_unpack(
    struct lynx19gw_brake_disk_temp_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t brake_disk_temp;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    brake_disk_temp = 0u;
    brake_disk_temp |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    brake_disk_temp |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    brake_disk_temp |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    brake_disk_temp |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->brake_disk_temp, &brake_disk_temp, sizeof(dst_p->brake_disk_temp));

    return (0);
}

float lynx19gw_brake_disk_temp_2_brake_disk_temp_encode(double value)
{
    return (float)(value);
}

double lynx19gw_brake_disk_temp_2_brake_disk_temp_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_brake_disk_temp_2_brake_disk_temp_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_damper_position_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_damper_position_1_t *src_p,
    size_t size)
{
    uint32_t damper_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&damper_position, &src_p->damper_position, sizeof(damper_position));
    dst_p[0] |= pack_left_shift_u32(damper_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(damper_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(damper_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(damper_position, 24u, 0xffu);

    return (4);
}

int lynx19gw_damper_position_1_unpack(
    struct lynx19gw_damper_position_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t damper_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    damper_position = 0u;
    damper_position |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    damper_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    damper_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    damper_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->damper_position, &damper_position, sizeof(dst_p->damper_position));

    return (0);
}

float lynx19gw_damper_position_1_damper_position_encode(double value)
{
    return (float)(value);
}

double lynx19gw_damper_position_1_damper_position_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_damper_position_1_damper_position_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_damper_position_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_damper_position_2_t *src_p,
    size_t size)
{
    uint32_t damper_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&damper_position, &src_p->damper_position, sizeof(damper_position));
    dst_p[0] |= pack_left_shift_u32(damper_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(damper_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(damper_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(damper_position, 24u, 0xffu);

    return (4);
}

int lynx19gw_damper_position_2_unpack(
    struct lynx19gw_damper_position_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t damper_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    damper_position = 0u;
    damper_position |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    damper_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    damper_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    damper_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->damper_position, &damper_position, sizeof(dst_p->damper_position));

    return (0);
}

float lynx19gw_damper_position_2_damper_position_encode(double value)
{
    return (float)(value);
}

double lynx19gw_damper_position_2_damper_position_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_damper_position_2_damper_position_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_pnuematic_pressure_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pnuematic_pressure_1_t *src_p,
    size_t size)
{
    uint32_t pnuematic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&pnuematic_pressure, &src_p->pnuematic_pressure, sizeof(pnuematic_pressure));
    dst_p[0] |= pack_left_shift_u32(pnuematic_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pnuematic_pressure, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pnuematic_pressure, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pnuematic_pressure, 24u, 0xffu);

    return (4);
}

int lynx19gw_pnuematic_pressure_1_unpack(
    struct lynx19gw_pnuematic_pressure_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pnuematic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    pnuematic_pressure = 0u;
    pnuematic_pressure |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pnuematic_pressure, &pnuematic_pressure, sizeof(dst_p->pnuematic_pressure));

    return (0);
}

float lynx19gw_pnuematic_pressure_1_pnuematic_pressure_encode(double value)
{
    return (float)(value);
}

double lynx19gw_pnuematic_pressure_1_pnuematic_pressure_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_pnuematic_pressure_1_pnuematic_pressure_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_pnuematic_pressure_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pnuematic_pressure_2_t *src_p,
    size_t size)
{
    uint32_t pnuematic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&pnuematic_pressure, &src_p->pnuematic_pressure, sizeof(pnuematic_pressure));
    dst_p[0] |= pack_left_shift_u32(pnuematic_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pnuematic_pressure, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pnuematic_pressure, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pnuematic_pressure, 24u, 0xffu);

    return (4);
}

int lynx19gw_pnuematic_pressure_2_unpack(
    struct lynx19gw_pnuematic_pressure_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pnuematic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    pnuematic_pressure = 0u;
    pnuematic_pressure |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pnuematic_pressure, &pnuematic_pressure, sizeof(dst_p->pnuematic_pressure));

    return (0);
}

float lynx19gw_pnuematic_pressure_2_pnuematic_pressure_encode(double value)
{
    return (float)(value);
}

double lynx19gw_pnuematic_pressure_2_pnuematic_pressure_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_pnuematic_pressure_2_pnuematic_pressure_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_pnuematic_pressure_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_pnuematic_pressure_3_t *src_p,
    size_t size)
{
    uint32_t pnuematic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&pnuematic_pressure, &src_p->pnuematic_pressure, sizeof(pnuematic_pressure));
    dst_p[0] |= pack_left_shift_u32(pnuematic_pressure, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(pnuematic_pressure, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(pnuematic_pressure, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(pnuematic_pressure, 24u, 0xffu);

    return (4);
}

int lynx19gw_pnuematic_pressure_3_unpack(
    struct lynx19gw_pnuematic_pressure_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t pnuematic_pressure;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    pnuematic_pressure = 0u;
    pnuematic_pressure |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    pnuematic_pressure |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->pnuematic_pressure, &pnuematic_pressure, sizeof(dst_p->pnuematic_pressure));

    return (0);
}

float lynx19gw_pnuematic_pressure_3_pnuematic_pressure_encode(double value)
{
    return (float)(value);
}

double lynx19gw_pnuematic_pressure_3_pnuematic_pressure_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_pnuematic_pressure_3_pnuematic_pressure_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_steering_position_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_steering_position_1_t *src_p,
    size_t size)
{
    uint32_t steering_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&steering_position, &src_p->steering_position, sizeof(steering_position));
    dst_p[0] |= pack_left_shift_u32(steering_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering_position, 24u, 0xffu);

    return (4);
}

int lynx19gw_steering_position_1_unpack(
    struct lynx19gw_steering_position_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t steering_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    steering_position = 0u;
    steering_position |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering_position, &steering_position, sizeof(dst_p->steering_position));

    return (0);
}

float lynx19gw_steering_position_1_steering_position_encode(double value)
{
    return (float)(value);
}

double lynx19gw_steering_position_1_steering_position_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_steering_position_1_steering_position_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_steering_position_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_steering_position_2_t *src_p,
    size_t size)
{
    uint32_t steering_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 4);

    memcpy(&steering_position, &src_p->steering_position, sizeof(steering_position));
    dst_p[0] |= pack_left_shift_u32(steering_position, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(steering_position, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(steering_position, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(steering_position, 24u, 0xffu);

    return (4);
}

int lynx19gw_steering_position_2_unpack(
    struct lynx19gw_steering_position_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t steering_position;

    if (size < 4u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    steering_position = 0u;
    steering_position |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    steering_position |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    steering_position |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    steering_position |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->steering_position, &steering_position, sizeof(dst_p->steering_position));

    return (0);
}

float lynx19gw_steering_position_2_steering_position_encode(double value)
{
    return (float)(value);
}

double lynx19gw_steering_position_2_steering_position_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_steering_position_2_steering_position_is_in_range(float value)
{
    return ((value >= 0.0f) && (value <= 100.0f));
}

int lynx19gw_test_can_message_1_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_1_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->test_message, 0u, 0xffu);

    return (1);
}

int lynx19gw_test_can_message_1_unpack(
    struct lynx19gw_test_can_message_1_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->test_message |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_test_can_message_1_test_message_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_test_can_message_1_test_message_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_test_can_message_1_test_message_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_test_can_message_2_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_2_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->test_message, 0u, 0xffu);

    return (1);
}

int lynx19gw_test_can_message_2_unpack(
    struct lynx19gw_test_can_message_2_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->test_message |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_test_can_message_2_test_message_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_test_can_message_2_test_message_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_test_can_message_2_test_message_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_test_can_message_3_pack(
    uint8_t *dst_p,
    const struct lynx19gw_test_can_message_3_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->test_message, 0u, 0xffu);

    return (1);
}

int lynx19gw_test_can_message_3_unpack(
    struct lynx19gw_test_can_message_3_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->test_message |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_test_can_message_3_test_message_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_test_can_message_3_test_message_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_test_can_message_3_test_message_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

int lynx19gw_safety_layer_pack(
    uint8_t *dst_p,
    const struct lynx19gw_safety_layer_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->as_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->asms_on, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->res_state, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->res_stop_signal, 2u, 0x04u);
    dst_p[1] |= pack_left_shift_u8(src_p->res_go_signal, 3u, 0x08u);
    dst_p[1] |= pack_left_shift_u8(src_p->res_initialized, 4u, 0x10u);
    dst_p[1] |= pack_left_shift_u8(src_p->brakes_released, 5u, 0x20u);
    dst_p[1] |= pack_left_shift_u8(src_p->ts_on, 6u, 0x40u);
    dst_p[1] |= pack_left_shift_u8(src_p->as_heartbeat, 7u, 0x80u);

    return (2);
}

int lynx19gw_safety_layer_unpack(
    struct lynx19gw_safety_layer_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->as_state |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->asms_on |= unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->res_state |= unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->res_stop_signal |= unpack_right_shift_u8(src_p[1], 2u, 0x04u);
    dst_p->res_go_signal |= unpack_right_shift_u8(src_p[1], 3u, 0x08u);
    dst_p->res_initialized |= unpack_right_shift_u8(src_p[1], 4u, 0x10u);
    dst_p->brakes_released |= unpack_right_shift_u8(src_p[1], 5u, 0x20u);
    dst_p->ts_on |= unpack_right_shift_u8(src_p[1], 6u, 0x40u);
    dst_p->as_heartbeat |= unpack_right_shift_u8(src_p[1], 7u, 0x80u);

    return (0);
}

uint8_t lynx19gw_safety_layer_as_state_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_as_state_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_as_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_safety_layer_asms_on_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_asms_on_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_asms_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_res_state_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_res_state_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_res_state_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_res_stop_signal_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_res_stop_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_res_stop_signal_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_res_go_signal_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_res_go_signal_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_res_go_signal_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_res_initialized_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_res_initialized_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_res_initialized_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_brakes_released_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_brakes_released_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_brakes_released_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_ts_on_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_ts_on_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_ts_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_safety_layer_as_heartbeat_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_safety_layer_as_heartbeat_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_safety_layer_as_heartbeat_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int lynx19gw_vehicle_speed_pack(
    uint8_t *dst_p,
    const struct lynx19gw_vehicle_speed_t *src_p,
    size_t size)
{
    uint32_t wheel_front_left;
    uint32_t wheel_front_right;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 8);

    memcpy(&wheel_front_right, &src_p->wheel_front_right, sizeof(wheel_front_right));
    dst_p[0] |= pack_left_shift_u32(wheel_front_right, 0u, 0xffu);
    dst_p[1] |= pack_right_shift_u32(wheel_front_right, 8u, 0xffu);
    dst_p[2] |= pack_right_shift_u32(wheel_front_right, 16u, 0xffu);
    dst_p[3] |= pack_right_shift_u32(wheel_front_right, 24u, 0xffu);
    memcpy(&wheel_front_left, &src_p->wheel_front_left, sizeof(wheel_front_left));
    dst_p[4] |= pack_left_shift_u32(wheel_front_left, 0u, 0xffu);
    dst_p[5] |= pack_right_shift_u32(wheel_front_left, 8u, 0xffu);
    dst_p[6] |= pack_right_shift_u32(wheel_front_left, 16u, 0xffu);
    dst_p[7] |= pack_right_shift_u32(wheel_front_left, 24u, 0xffu);

    return (8);
}

int lynx19gw_vehicle_speed_unpack(
    struct lynx19gw_vehicle_speed_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    uint32_t wheel_front_left;
    uint32_t wheel_front_right;

    if (size < 8u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    wheel_front_right = 0u;
    wheel_front_right |= unpack_right_shift_u32(src_p[0], 0u, 0xffu);
    wheel_front_right |= unpack_left_shift_u32(src_p[1], 8u, 0xffu);
    wheel_front_right |= unpack_left_shift_u32(src_p[2], 16u, 0xffu);
    wheel_front_right |= unpack_left_shift_u32(src_p[3], 24u, 0xffu);
    memcpy(&dst_p->wheel_front_right, &wheel_front_right, sizeof(dst_p->wheel_front_right));
    wheel_front_left = 0u;
    wheel_front_left |= unpack_right_shift_u32(src_p[4], 0u, 0xffu);
    wheel_front_left |= unpack_left_shift_u32(src_p[5], 8u, 0xffu);
    wheel_front_left |= unpack_left_shift_u32(src_p[6], 16u, 0xffu);
    wheel_front_left |= unpack_left_shift_u32(src_p[7], 24u, 0xffu);
    memcpy(&dst_p->wheel_front_left, &wheel_front_left, sizeof(dst_p->wheel_front_left));

    return (0);
}

float lynx19gw_vehicle_speed_wheel_front_right_encode(double value)
{
    return (float)(value);
}

double lynx19gw_vehicle_speed_wheel_front_right_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_vehicle_speed_wheel_front_right_is_in_range(float value)
{
    (void)value;

    return (true);
}

float lynx19gw_vehicle_speed_wheel_front_left_encode(double value)
{
    return (float)(value);
}

double lynx19gw_vehicle_speed_wheel_front_left_decode(float value)
{
    return ((double)value);
}

bool lynx19gw_vehicle_speed_wheel_front_left_is_in_range(float value)
{
    (void)value;

    return (true);
}

int lynx19gw_ebs_pack(
    uint8_t *dst_p,
    const struct lynx19gw_ebs_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 2);

    dst_p[0] |= pack_left_shift_u8(src_p->ebs_state, 0u, 0xffu);
    dst_p[1] |= pack_left_shift_u8(src_p->ebs_armed, 0u, 0x01u);
    dst_p[1] |= pack_left_shift_u8(src_p->ebs_activated, 1u, 0x02u);
    dst_p[1] |= pack_left_shift_u8(src_p->ebs_speaker_on, 2u, 0x04u);

    return (2);
}

int lynx19gw_ebs_unpack(
    struct lynx19gw_ebs_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 2u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->ebs_state |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);
    dst_p->ebs_armed |= unpack_right_shift_u8(src_p[1], 0u, 0x01u);
    dst_p->ebs_activated |= unpack_right_shift_u8(src_p[1], 1u, 0x02u);
    dst_p->ebs_speaker_on |= unpack_right_shift_u8(src_p[1], 2u, 0x04u);

    return (0);
}

uint8_t lynx19gw_ebs_ebs_state_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_ebs_ebs_state_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_ebs_ebs_state_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

uint8_t lynx19gw_ebs_ebs_armed_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_ebs_ebs_armed_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_ebs_ebs_armed_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_ebs_ebs_activated_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_ebs_ebs_activated_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_ebs_ebs_activated_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

uint8_t lynx19gw_ebs_ebs_speaker_on_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_ebs_ebs_speaker_on_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_ebs_ebs_speaker_on_is_in_range(uint8_t value)
{
    return (value <= 1u);
}

int lynx19gw_as_mission_pack(
    uint8_t *dst_p,
    const struct lynx19gw_as_mission_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(&dst_p[0], 0, 1);

    dst_p[0] |= pack_left_shift_u8(src_p->mission_select, 0u, 0xffu);

    return (1);
}

int lynx19gw_as_mission_unpack(
    struct lynx19gw_as_mission_t *dst_p,
    const uint8_t *src_p,
    size_t size)
{
    if (size < 1u) {
        return (-EINVAL);
    }

    memset(dst_p, 0, sizeof(*dst_p));

    dst_p->mission_select |= unpack_right_shift_u8(src_p[0], 0u, 0xffu);

    return (0);
}

uint8_t lynx19gw_as_mission_mission_select_encode(double value)
{
    return (uint8_t)(value);
}

double lynx19gw_as_mission_mission_select_decode(uint8_t value)
{
    return ((double)value);
}

bool lynx19gw_as_mission_mission_select_is_in_range(uint8_t value)
{
    (void)value;

    return (true);
}

/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_TEST_HPP
#define OPENDLV_CFSDPROXYCANREADING_TEST_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API Test {
    private:
        static constexpr const char* TheShortName = "Test";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.Test";

    public:
        inline static int32_t ID() {
            return 1001;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Test() = default;
        Test(const Test&) = default;
        Test& operator=(const Test&) = default;
        Test(Test&&) = default;
        Test& operator=(Test&&) = default;
        ~Test() = default;

    public:
        
        inline Test& testCanMessage1(const int &v) noexcept {
            m_testCanMessage1 = v;
            return *this;
        }
        inline int testCanMessage1() const noexcept {
            return m_testCanMessage1;
        }
        
        inline Test& testCanMessage2(const int &v) noexcept {
            m_testCanMessage2 = v;
            return *this;
        }
        inline int testCanMessage2() const noexcept {
            return m_testCanMessage2;
        }
        
        inline Test& testCanMessage3(const int &v) noexcept {
            m_testCanMessage3 = v;
            return *this;
        }
        inline int testCanMessage3() const noexcept {
            return m_testCanMessage3;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("testCanMessage1"s), m_testCanMessage1, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("testCanMessage2"s), m_testCanMessage2, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("int"s), std::move("testCanMessage3"s), m_testCanMessage3, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("testCanMessage1"s), m_testCanMessage1, visitor);
            
            doVisit(2, std::move("int"s), std::move("testCanMessage2"s), m_testCanMessage2, visitor);
            
            doVisit(3, std::move("int"s), std::move("testCanMessage3"s), m_testCanMessage3, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("testCanMessage1"s), m_testCanMessage1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("testCanMessage2"s), m_testCanMessage2, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("int"s), std::move("testCanMessage3"s), m_testCanMessage3, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_testCanMessage1{  }; // field identifier = 1.
        
        int m_testCanMessage2{  }; // field identifier = 2.
        
        int m_testCanMessage3{  }; // field identifier = 3.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::Test> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::Test> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_SENSORS_HPP
#define OPENDLV_CFSDPROXYCANREADING_SENSORS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API Sensors {
    private:
        static constexpr const char* TheShortName = "Sensors";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.Sensors";

    public:
        inline static int32_t ID() {
            return 1002;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        Sensors() = default;
        Sensors(const Sensors&) = default;
        Sensors& operator=(const Sensors&) = default;
        Sensors(Sensors&&) = default;
        Sensors& operator=(Sensors&&) = default;
        ~Sensors() = default;

    public:
        
        inline Sensors& apps1throttlePercentage(const float &v) noexcept {
            m_apps1throttlePercentage = v;
            return *this;
        }
        inline float apps1throttlePercentage() const noexcept {
            return m_apps1throttlePercentage;
        }
        
        inline Sensors& apps2throttlePercentage(const float &v) noexcept {
            m_apps2throttlePercentage = v;
            return *this;
        }
        inline float apps2throttlePercentage() const noexcept {
            return m_apps2throttlePercentage;
        }
        
        inline Sensors& hydraulicPressure1(const float &v) noexcept {
            m_hydraulicPressure1 = v;
            return *this;
        }
        inline float hydraulicPressure1() const noexcept {
            return m_hydraulicPressure1;
        }
        
        inline Sensors& hydraulicPressure2(const float &v) noexcept {
            m_hydraulicPressure2 = v;
            return *this;
        }
        inline float hydraulicPressure2() const noexcept {
            return m_hydraulicPressure2;
        }
        
        inline Sensors& brakeDiscTemp1(const float &v) noexcept {
            m_brakeDiscTemp1 = v;
            return *this;
        }
        inline float brakeDiscTemp1() const noexcept {
            return m_brakeDiscTemp1;
        }
        
        inline Sensors& brakeDiscTemp2(const float &v) noexcept {
            m_brakeDiscTemp2 = v;
            return *this;
        }
        inline float brakeDiscTemp2() const noexcept {
            return m_brakeDiscTemp2;
        }
        
        inline Sensors& damperPosition1(const float &v) noexcept {
            m_damperPosition1 = v;
            return *this;
        }
        inline float damperPosition1() const noexcept {
            return m_damperPosition1;
        }
        
        inline Sensors& damperPosition2(const float &v) noexcept {
            m_damperPosition2 = v;
            return *this;
        }
        inline float damperPosition2() const noexcept {
            return m_damperPosition2;
        }
        
        inline Sensors& pnuematicPressure1(const float &v) noexcept {
            m_pnuematicPressure1 = v;
            return *this;
        }
        inline float pnuematicPressure1() const noexcept {
            return m_pnuematicPressure1;
        }
        
        inline Sensors& pnuematicPressure2(const float &v) noexcept {
            m_pnuematicPressure2 = v;
            return *this;
        }
        inline float pnuematicPressure2() const noexcept {
            return m_pnuematicPressure2;
        }
        
        inline Sensors& pnuematicPressure3(const float &v) noexcept {
            m_pnuematicPressure3 = v;
            return *this;
        }
        inline float pnuematicPressure3() const noexcept {
            return m_pnuematicPressure3;
        }
        
        inline Sensors& steeringPosition1(const float &v) noexcept {
            m_steeringPosition1 = v;
            return *this;
        }
        inline float steeringPosition1() const noexcept {
            return m_steeringPosition1;
        }
        
        inline Sensors& steeringPosition2(const float &v) noexcept {
            m_steeringPosition2 = v;
            return *this;
        }
        inline float steeringPosition2() const noexcept {
            return m_steeringPosition2;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("apps1throttlePercentage"s), m_apps1throttlePercentage, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("apps2throttlePercentage"s), m_apps2throttlePercentage, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("float"s), std::move("hydraulicPressure1"s), m_hydraulicPressure1, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("float"s), std::move("hydraulicPressure2"s), m_hydraulicPressure2, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("float"s), std::move("brakeDiscTemp1"s), m_brakeDiscTemp1, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("float"s), std::move("brakeDiscTemp2"s), m_brakeDiscTemp2, visitor);
                return;
            }
            
            if (7 == fieldId) {
                doVisit(7, std::move("float"s), std::move("damperPosition1"s), m_damperPosition1, visitor);
                return;
            }
            
            if (8 == fieldId) {
                doVisit(8, std::move("float"s), std::move("damperPosition2"s), m_damperPosition2, visitor);
                return;
            }
            
            if (9 == fieldId) {
                doVisit(9, std::move("float"s), std::move("pnuematicPressure1"s), m_pnuematicPressure1, visitor);
                return;
            }
            
            if (10 == fieldId) {
                doVisit(10, std::move("float"s), std::move("pnuematicPressure2"s), m_pnuematicPressure2, visitor);
                return;
            }
            
            if (11 == fieldId) {
                doVisit(11, std::move("float"s), std::move("pnuematicPressure3"s), m_pnuematicPressure3, visitor);
                return;
            }
            
            if (12 == fieldId) {
                doVisit(12, std::move("float"s), std::move("steeringPosition1"s), m_steeringPosition1, visitor);
                return;
            }
            
            if (13 == fieldId) {
                doVisit(13, std::move("float"s), std::move("steeringPosition2"s), m_steeringPosition2, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("apps1throttlePercentage"s), m_apps1throttlePercentage, visitor);
            
            doVisit(2, std::move("float"s), std::move("apps2throttlePercentage"s), m_apps2throttlePercentage, visitor);
            
            doVisit(3, std::move("float"s), std::move("hydraulicPressure1"s), m_hydraulicPressure1, visitor);
            
            doVisit(4, std::move("float"s), std::move("hydraulicPressure2"s), m_hydraulicPressure2, visitor);
            
            doVisit(5, std::move("float"s), std::move("brakeDiscTemp1"s), m_brakeDiscTemp1, visitor);
            
            doVisit(6, std::move("float"s), std::move("brakeDiscTemp2"s), m_brakeDiscTemp2, visitor);
            
            doVisit(7, std::move("float"s), std::move("damperPosition1"s), m_damperPosition1, visitor);
            
            doVisit(8, std::move("float"s), std::move("damperPosition2"s), m_damperPosition2, visitor);
            
            doVisit(9, std::move("float"s), std::move("pnuematicPressure1"s), m_pnuematicPressure1, visitor);
            
            doVisit(10, std::move("float"s), std::move("pnuematicPressure2"s), m_pnuematicPressure2, visitor);
            
            doVisit(11, std::move("float"s), std::move("pnuematicPressure3"s), m_pnuematicPressure3, visitor);
            
            doVisit(12, std::move("float"s), std::move("steeringPosition1"s), m_steeringPosition1, visitor);
            
            doVisit(13, std::move("float"s), std::move("steeringPosition2"s), m_steeringPosition2, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("apps1throttlePercentage"s), m_apps1throttlePercentage, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("apps2throttlePercentage"s), m_apps2throttlePercentage, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("float"s), std::move("hydraulicPressure1"s), m_hydraulicPressure1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("float"s), std::move("hydraulicPressure2"s), m_hydraulicPressure2, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("float"s), std::move("brakeDiscTemp1"s), m_brakeDiscTemp1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("float"s), std::move("brakeDiscTemp2"s), m_brakeDiscTemp2, preVisit, visit, postVisit);
            
            doTripletForwardVisit(7, std::move("float"s), std::move("damperPosition1"s), m_damperPosition1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(8, std::move("float"s), std::move("damperPosition2"s), m_damperPosition2, preVisit, visit, postVisit);
            
            doTripletForwardVisit(9, std::move("float"s), std::move("pnuematicPressure1"s), m_pnuematicPressure1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(10, std::move("float"s), std::move("pnuematicPressure2"s), m_pnuematicPressure2, preVisit, visit, postVisit);
            
            doTripletForwardVisit(11, std::move("float"s), std::move("pnuematicPressure3"s), m_pnuematicPressure3, preVisit, visit, postVisit);
            
            doTripletForwardVisit(12, std::move("float"s), std::move("steeringPosition1"s), m_steeringPosition1, preVisit, visit, postVisit);
            
            doTripletForwardVisit(13, std::move("float"s), std::move("steeringPosition2"s), m_steeringPosition2, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_apps1throttlePercentage{ 0.0f }; // field identifier = 1.
        
        float m_apps2throttlePercentage{ 0.0f }; // field identifier = 2.
        
        float m_hydraulicPressure1{ 0.0f }; // field identifier = 3.
        
        float m_hydraulicPressure2{ 0.0f }; // field identifier = 4.
        
        float m_brakeDiscTemp1{ 0.0f }; // field identifier = 5.
        
        float m_brakeDiscTemp2{ 0.0f }; // field identifier = 6.
        
        float m_damperPosition1{ 0.0f }; // field identifier = 7.
        
        float m_damperPosition2{ 0.0f }; // field identifier = 8.
        
        float m_pnuematicPressure1{ 0.0f }; // field identifier = 9.
        
        float m_pnuematicPressure2{ 0.0f }; // field identifier = 10.
        
        float m_pnuematicPressure3{ 0.0f }; // field identifier = 11.
        
        float m_steeringPosition1{ 0.0f }; // field identifier = 12.
        
        float m_steeringPosition2{ 0.0f }; // field identifier = 13.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::Sensors> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::Sensors> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_NODESTATUS_HPP
#define OPENDLV_CFSDPROXYCANREADING_NODESTATUS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API NodeStatus {
    private:
        static constexpr const char* TheShortName = "NodeStatus";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.NodeStatus";

    public:
        inline static int32_t ID() {
            return 1003;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        NodeStatus() = default;
        NodeStatus(const NodeStatus&) = default;
        NodeStatus& operator=(const NodeStatus&) = default;
        NodeStatus(NodeStatus&&) = default;
        NodeStatus& operator=(NodeStatus&&) = default;
        ~NodeStatus() = default;

    public:
        
        inline NodeStatus& counter(const int &v) noexcept {
            m_counter = v;
            return *this;
        }
        inline int counter() const noexcept {
            return m_counter;
        }
        
        inline NodeStatus& readyToDrive(const int &v) noexcept {
            m_readyToDrive = v;
            return *this;
        }
        inline int readyToDrive() const noexcept {
            return m_readyToDrive;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("counter"s), m_counter, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("readyToDrive"s), m_readyToDrive, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("counter"s), m_counter, visitor);
            
            doVisit(2, std::move("int"s), std::move("readyToDrive"s), m_readyToDrive, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("counter"s), m_counter, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("readyToDrive"s), m_readyToDrive, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_counter{  }; // field identifier = 1.
        
        int m_readyToDrive{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::NodeStatus> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::NodeStatus> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_SAFETYLAYER_HPP
#define OPENDLV_CFSDPROXYCANREADING_SAFETYLAYER_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API SafetyLayer {
    private:
        static constexpr const char* TheShortName = "SafetyLayer";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.SafetyLayer";

    public:
        inline static int32_t ID() {
            return 2001;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        SafetyLayer() = default;
        SafetyLayer(const SafetyLayer&) = default;
        SafetyLayer& operator=(const SafetyLayer&) = default;
        SafetyLayer(SafetyLayer&&) = default;
        SafetyLayer& operator=(SafetyLayer&&) = default;
        ~SafetyLayer() = default;

    public:
        
        inline SafetyLayer& asmsOn(const bool &v) noexcept {
            m_asmsOn = v;
            return *this;
        }
        inline bool asmsOn() const noexcept {
            return m_asmsOn;
        }
        
        inline SafetyLayer& resState(const bool &v) noexcept {
            m_resState = v;
            return *this;
        }
        inline bool resState() const noexcept {
            return m_resState;
        }
        
        inline SafetyLayer& resStopSignal(const bool &v) noexcept {
            m_resStopSignal = v;
            return *this;
        }
        inline bool resStopSignal() const noexcept {
            return m_resStopSignal;
        }
        
        inline SafetyLayer& resGoSignal(const bool &v) noexcept {
            m_resGoSignal = v;
            return *this;
        }
        inline bool resGoSignal() const noexcept {
            return m_resGoSignal;
        }
        
        inline SafetyLayer& resInitialized(const bool &v) noexcept {
            m_resInitialized = v;
            return *this;
        }
        inline bool resInitialized() const noexcept {
            return m_resInitialized;
        }
        
        inline SafetyLayer& brakesReleased(const bool &v) noexcept {
            m_brakesReleased = v;
            return *this;
        }
        inline bool brakesReleased() const noexcept {
            return m_brakesReleased;
        }
        
        inline SafetyLayer& tsOn(const bool &v) noexcept {
            m_tsOn = v;
            return *this;
        }
        inline bool tsOn() const noexcept {
            return m_tsOn;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("bool"s), std::move("asmsOn"s), m_asmsOn, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("bool"s), std::move("resState"s), m_resState, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("bool"s), std::move("resStopSignal"s), m_resStopSignal, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("bool"s), std::move("resGoSignal"s), m_resGoSignal, visitor);
                return;
            }
            
            if (5 == fieldId) {
                doVisit(5, std::move("bool"s), std::move("resInitialized"s), m_resInitialized, visitor);
                return;
            }
            
            if (6 == fieldId) {
                doVisit(6, std::move("bool"s), std::move("brakesReleased"s), m_brakesReleased, visitor);
                return;
            }
            
            if (7 == fieldId) {
                doVisit(7, std::move("bool"s), std::move("tsOn"s), m_tsOn, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("bool"s), std::move("asmsOn"s), m_asmsOn, visitor);
            
            doVisit(2, std::move("bool"s), std::move("resState"s), m_resState, visitor);
            
            doVisit(3, std::move("bool"s), std::move("resStopSignal"s), m_resStopSignal, visitor);
            
            doVisit(4, std::move("bool"s), std::move("resGoSignal"s), m_resGoSignal, visitor);
            
            doVisit(5, std::move("bool"s), std::move("resInitialized"s), m_resInitialized, visitor);
            
            doVisit(6, std::move("bool"s), std::move("brakesReleased"s), m_brakesReleased, visitor);
            
            doVisit(7, std::move("bool"s), std::move("tsOn"s), m_tsOn, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("bool"s), std::move("asmsOn"s), m_asmsOn, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("bool"s), std::move("resState"s), m_resState, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("bool"s), std::move("resStopSignal"s), m_resStopSignal, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("bool"s), std::move("resGoSignal"s), m_resGoSignal, preVisit, visit, postVisit);
            
            doTripletForwardVisit(5, std::move("bool"s), std::move("resInitialized"s), m_resInitialized, preVisit, visit, postVisit);
            
            doTripletForwardVisit(6, std::move("bool"s), std::move("brakesReleased"s), m_brakesReleased, preVisit, visit, postVisit);
            
            doTripletForwardVisit(7, std::move("bool"s), std::move("tsOn"s), m_tsOn, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        bool m_asmsOn{ false }; // field identifier = 1.
        
        bool m_resState{ false }; // field identifier = 2.
        
        bool m_resStopSignal{ false }; // field identifier = 3.
        
        bool m_resGoSignal{ false }; // field identifier = 4.
        
        bool m_resInitialized{ false }; // field identifier = 5.
        
        bool m_brakesReleased{ false }; // field identifier = 6.
        
        bool m_tsOn{ false }; // field identifier = 7.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::SafetyLayer> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::SafetyLayer> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_VEHICLESPEED_HPP
#define OPENDLV_CFSDPROXYCANREADING_VEHICLESPEED_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API VehicleSpeed {
    private:
        static constexpr const char* TheShortName = "VehicleSpeed";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.VehicleSpeed";

    public:
        inline static int32_t ID() {
            return 2002;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        VehicleSpeed() = default;
        VehicleSpeed(const VehicleSpeed&) = default;
        VehicleSpeed& operator=(const VehicleSpeed&) = default;
        VehicleSpeed(VehicleSpeed&&) = default;
        VehicleSpeed& operator=(VehicleSpeed&&) = default;
        ~VehicleSpeed() = default;

    public:
        
        inline VehicleSpeed& wheelFrontRight(const float &v) noexcept {
            m_wheelFrontRight = v;
            return *this;
        }
        inline float wheelFrontRight() const noexcept {
            return m_wheelFrontRight;
        }
        
        inline VehicleSpeed& wheelFrontLeft(const float &v) noexcept {
            m_wheelFrontLeft = v;
            return *this;
        }
        inline float wheelFrontLeft() const noexcept {
            return m_wheelFrontLeft;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, visitor);
            
            doVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("float"s), std::move("wheelFrontRight"s), m_wheelFrontRight, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("float"s), std::move("wheelFrontLeft"s), m_wheelFrontLeft, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        float m_wheelFrontRight{ 0.0f }; // field identifier = 1.
        
        float m_wheelFrontLeft{ 0.0f }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::VehicleSpeed> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::VehicleSpeed> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_EBS_HPP
#define OPENDLV_CFSDPROXYCANREADING_EBS_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API EBS {
    private:
        static constexpr const char* TheShortName = "EBS";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.EBS";

    public:
        inline static int32_t ID() {
            return 2003;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        EBS() = default;
        EBS(const EBS&) = default;
        EBS& operator=(const EBS&) = default;
        EBS(EBS&&) = default;
        EBS& operator=(EBS&&) = default;
        ~EBS() = default;

    public:
        
        inline EBS& ebsState(const bool &v) noexcept {
            m_ebsState = v;
            return *this;
        }
        inline bool ebsState() const noexcept {
            return m_ebsState;
        }
        
        inline EBS& ebsArmed(const bool &v) noexcept {
            m_ebsArmed = v;
            return *this;
        }
        inline bool ebsArmed() const noexcept {
            return m_ebsArmed;
        }
        
        inline EBS& ebsActivated(const bool &v) noexcept {
            m_ebsActivated = v;
            return *this;
        }
        inline bool ebsActivated() const noexcept {
            return m_ebsActivated;
        }
        
        inline EBS& ebsSpeakerOn(const bool &v) noexcept {
            m_ebsSpeakerOn = v;
            return *this;
        }
        inline bool ebsSpeakerOn() const noexcept {
            return m_ebsSpeakerOn;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("bool"s), std::move("ebsState"s), m_ebsState, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("bool"s), std::move("ebsArmed"s), m_ebsArmed, visitor);
                return;
            }
            
            if (3 == fieldId) {
                doVisit(3, std::move("bool"s), std::move("ebsActivated"s), m_ebsActivated, visitor);
                return;
            }
            
            if (4 == fieldId) {
                doVisit(4, std::move("bool"s), std::move("ebsSpeakerOn"s), m_ebsSpeakerOn, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("bool"s), std::move("ebsState"s), m_ebsState, visitor);
            
            doVisit(2, std::move("bool"s), std::move("ebsArmed"s), m_ebsArmed, visitor);
            
            doVisit(3, std::move("bool"s), std::move("ebsActivated"s), m_ebsActivated, visitor);
            
            doVisit(4, std::move("bool"s), std::move("ebsSpeakerOn"s), m_ebsSpeakerOn, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("bool"s), std::move("ebsState"s), m_ebsState, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("bool"s), std::move("ebsArmed"s), m_ebsArmed, preVisit, visit, postVisit);
            
            doTripletForwardVisit(3, std::move("bool"s), std::move("ebsActivated"s), m_ebsActivated, preVisit, visit, postVisit);
            
            doTripletForwardVisit(4, std::move("bool"s), std::move("ebsSpeakerOn"s), m_ebsSpeakerOn, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        bool m_ebsState{ false }; // field identifier = 1.
        
        bool m_ebsArmed{ false }; // field identifier = 2.
        
        bool m_ebsActivated{ false }; // field identifier = 3.
        
        bool m_ebsSpeakerOn{ false }; // field identifier = 4.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::EBS> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::EBS> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANWRITING_ASMISSION_HPP
#define OPENDLV_CFSDPROXYCANWRITING_ASMISSION_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API ASMission {
    private:
        static constexpr const char* TheShortName = "ASMission";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANWriting.ASMission";

    public:
        inline static int32_t ID() {
            return 2004;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        ASMission() = default;
        ASMission(const ASMission&) = default;
        ASMission& operator=(const ASMission&) = default;
        ASMission(ASMission&&) = default;
        ASMission& operator=(ASMission&&) = default;
        ~ASMission() = default;

    public:
        
        inline ASMission& missionSelected(const int &v) noexcept {
            m_missionSelected = v;
            return *this;
        }
        inline int missionSelected() const noexcept {
            return m_missionSelected;
        }
        
        inline ASMission& missionStatus(const int &v) noexcept {
            m_missionStatus = v;
            return *this;
        }
        inline int missionStatus() const noexcept {
            return m_missionStatus;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("missionSelected"s), m_missionSelected, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("int"s), std::move("missionStatus"s), m_missionStatus, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("missionSelected"s), m_missionSelected, visitor);
            
            doVisit(2, std::move("int"s), std::move("missionStatus"s), m_missionStatus, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("missionSelected"s), m_missionSelected, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("int"s), std::move("missionStatus"s), m_missionStatus, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_missionSelected{  }; // field identifier = 1.
        
        int m_missionStatus{  }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANWriting::ASMission> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANWriting::ASMission> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANREADING_ASMISSION_HPP
#define OPENDLV_CFSDPROXYCANREADING_ASMISSION_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANReading {
using namespace std::string_literals; // NOLINT
class LIB_API ASMission {
    private:
        static constexpr const char* TheShortName = "ASMission";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANReading.ASMission";

    public:
        inline static int32_t ID() {
            return 2005;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        ASMission() = default;
        ASMission(const ASMission&) = default;
        ASMission& operator=(const ASMission&) = default;
        ASMission(ASMission&&) = default;
        ASMission& operator=(ASMission&&) = default;
        ~ASMission() = default;

    public:
        
        inline ASMission& missionSelect(const int &v) noexcept {
            m_missionSelect = v;
            return *this;
        }
        inline int missionSelect() const noexcept {
            return m_missionSelect;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("int"s), std::move("missionSelect"s), m_missionSelect, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("int"s), std::move("missionSelect"s), m_missionSelect, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("int"s), std::move("missionSelect"s), m_missionSelect, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        int m_missionSelect{  }; // field identifier = 1.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANReading::ASMission> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANReading::ASMission> {
    static const bool value = true;
};
#endif


/*
 * THIS IS AN AUTO-GENERATED FILE. DO NOT MODIFY AS CHANGES MIGHT BE OVERWRITTEN!
 */

#ifndef VISITABLE_TYPE_TRAIT
#define VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct visitorSelector {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct visitorSelector<true> {
    template<typename T, class Visitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
        visitor.visit(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<typename T>
struct isVisitable {
    static const bool value = false;
};

template<typename T, class Visitor>
void doVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, Visitor &visitor) {
    visitorSelector<isVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, visitor);
}
#endif

#ifndef TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#define TRIPLET_FORWARD_VISITABLE_TYPE_TRAIT
#include <cstdint>
#include <string>
#include <utility>

template<bool b>
struct tripletForwardVisitorSelector {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)preVisit;
        (void)postVisit;
        std::forward<Visitor>(visit)(fieldIdentifier, std::move(typeName), std::move(name), value);
    }
};

template<>
struct tripletForwardVisitorSelector<true> {
    template<typename T, class PreVisitor, class Visitor, class PostVisitor>
    static void impl(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
        (void)fieldIdentifier;
        (void)typeName;
        (void)name;
        // Apply preVisit, visit, and postVisit on value.
        value.accept(preVisit, visit, postVisit);
    }
};

template<typename T>
struct isTripletForwardVisitable {
    static const bool value = false;
};

template< typename T, class PreVisitor, class Visitor, class PostVisitor>
void doTripletForwardVisit(uint32_t fieldIdentifier, std::string &&typeName, std::string &&name, T &value, PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
    tripletForwardVisitorSelector<isTripletForwardVisitable<T>::value >::impl(fieldIdentifier, std::move(typeName), std::move(name), value, std::move(preVisit), std::move(visit), std::move(postVisit)); // NOLINT
}
#endif


#ifndef OPENDLV_CFSDPROXYCANWRITING_SAFETYLAYER_HPP
#define OPENDLV_CFSDPROXYCANWRITING_SAFETYLAYER_HPP

#ifdef WIN32
    // Export symbols if compile flags "LIB_SHARED" and "LIB_EXPORTS" are set on Windows.
    #ifdef LIB_SHARED
        #ifdef LIB_EXPORTS
            #define LIB_API __declspec(dllexport)
        #else
            #define LIB_API __declspec(dllimport)
        #endif
    #else
        // Disable definition if linking statically.
        #define LIB_API
    #endif
#else
    // Disable definition for non-Win32 systems.
    #define LIB_API
#endif

#include <string>
#include <utility>
namespace opendlv { namespace cfsdProxyCANWriting {
using namespace std::string_literals; // NOLINT
class LIB_API SafetyLayer {
    private:
        static constexpr const char* TheShortName = "SafetyLayer";
        static constexpr const char* TheLongName = "opendlv.cfsdProxyCANWriting.SafetyLayer";

    public:
        inline static int32_t ID() {
            return 2006;
        }
        inline static const std::string ShortName() {
            return TheShortName;
        }
        inline static const std::string LongName() {
            return TheLongName;
        }

    public:
        SafetyLayer() = default;
        SafetyLayer(const SafetyLayer&) = default;
        SafetyLayer& operator=(const SafetyLayer&) = default;
        SafetyLayer(SafetyLayer&&) = default;
        SafetyLayer& operator=(SafetyLayer&&) = default;
        ~SafetyLayer() = default;

    public:
        
        inline SafetyLayer& asHeartbeat(const bool &v) noexcept {
            m_asHeartbeat = v;
            return *this;
        }
        inline bool asHeartbeat() const noexcept {
            return m_asHeartbeat;
        }
        
        inline SafetyLayer& asState(const bool &v) noexcept {
            m_asState = v;
            return *this;
        }
        inline bool asState() const noexcept {
            return m_asState;
        }
        

    public:
        template<class Visitor>
        inline void accept(uint32_t fieldId, Visitor &visitor) {
            (void)fieldId;
            (void)visitor;
//            visitor.preVisit(ID(), ShortName(), LongName());
            
            if (1 == fieldId) {
                doVisit(1, std::move("bool"s), std::move("asHeartbeat"s), m_asHeartbeat, visitor);
                return;
            }
            
            if (2 == fieldId) {
                doVisit(2, std::move("bool"s), std::move("asState"s), m_asState, visitor);
                return;
            }
            
//            visitor.postVisit();
        }

        template<class Visitor>
        inline void accept(Visitor &visitor) {
            visitor.preVisit(ID(), ShortName(), LongName());
            
            doVisit(1, std::move("bool"s), std::move("asHeartbeat"s), m_asHeartbeat, visitor);
            
            doVisit(2, std::move("bool"s), std::move("asState"s), m_asState, visitor);
            
            visitor.postVisit();
        }

        template<class PreVisitor, class Visitor, class PostVisitor>
        inline void accept(PreVisitor &&preVisit, Visitor &&visit, PostVisitor &&postVisit) {
            (void)visit; // Prevent warnings from empty messages.
            std::forward<PreVisitor>(preVisit)(ID(), ShortName(), LongName());
            
            doTripletForwardVisit(1, std::move("bool"s), std::move("asHeartbeat"s), m_asHeartbeat, preVisit, visit, postVisit);
            
            doTripletForwardVisit(2, std::move("bool"s), std::move("asState"s), m_asState, preVisit, visit, postVisit);
            
            std::forward<PostVisitor>(postVisit)();
        }

    private:
        
        bool m_asHeartbeat{ false }; // field identifier = 1.
        
        bool m_asState{ false }; // field identifier = 2.
        
};
}}

template<>
struct isVisitable<opendlv::cfsdProxyCANWriting::SafetyLayer> {
    static const bool value = true;
};
template<>
struct isTripletForwardVisitable<opendlv::cfsdProxyCANWriting::SafetyLayer> {
    static const bool value = true;
};
#endif

